# US-010: ClasificaciÃ³n SemÃ¡ntica de Objetos Post-SegmentaciÃ³n

**Estado:** ğŸ“‹ PLANEACIÃ“N
**Fecha de CreaciÃ³n:** 11 de Noviembre de 2025
**Equipo:** 24 - Region Growing
**Desarrollador Asignado:** Arthur Zizumbo
**EstimaciÃ³n:** 8 horas
**Prioridad:** ALTA (Fundamental para interpretabilidad)

---

## ğŸ“‹ Historia de Usuario

**Como** investigador
**Quiero** clasificar semÃ¡nticamente cada objeto segmentado por MGRG (asignar etiquetas como "Agua", "Cultivo Vigoroso", "Urbano", "Suelo Desnudo")
**Para que** el resultado final no sea solo un conjunto de regiones anÃ³nimas (Objeto 1-N), sino un mapa de cobertura terrestre clasificado e interpretable

---

## ğŸ¯ Contexto y MotivaciÃ³n

### Problema Actual
- **US-007 (MGRG) produce regiones sin etiquetas semÃ¡nticas**: "RegiÃ³n 45" no es interpretable
- **AnÃ¡lisis de estrÃ©s se aplica a todas las regiones**: No distingue entre cultivos y zonas urbanas
- **Mapas no son autoexplicativos**: DifÃ­cil comunicar resultados a stakeholders no tÃ©cnicos
- **Falta jerarquÃ­a**: Necesitamos clasificar PRIMERO la clase, LUEGO el estrÃ©s (solo para cultivos)

### Estado del Arte (2024-2025)
SegÃºn investigaciÃ³n de papers recientes:
- **Zero-Shot Classification**: SAM-CLIP 2024 logra +6.8% mIoU vs mÃ©todos anteriores
- **Prithvi-EO-2.0**: Mejor modelo en segmentaciÃ³n (Diciembre 2024), embeddings 256D ideales para clasificaciÃ³n
- **Hierarchical Classification**: Transfer learning con niveles (Coarse â†’ Fine) mejora resultados
- **Agricultural Applications**: 70-75% accuracy en clasificaciÃ³n de cobertura terrestre

### SoluciÃ³n Propuesta
**ClasificaciÃ³n JerÃ¡rquica Zero-Shot con NDVI + Embeddings:**

**Nivel 1 - Coarse Classes (6 categorÃ­as):**
1. **Water** (Agua)
2. **Urban** (Ãrea urbana/construida)
3. **Bare Soil** (Suelo desnudo/barbecho)
4. **Vigorous Crop** (Cultivo vigoroso - NDVI >0.6)
5. **Stressed Crop** (Cultivo estresado - 0.3 < NDVI < 0.6)
6. **Grass/Shrub** (VegetaciÃ³n natural)

**Nivel 2 - Stress Analysis (solo para cultivos):**
- Bajo estrÃ©s: NDVI 0.5-0.6
- Medio estrÃ©s: NDVI 0.4-0.5
- Alto estrÃ©s: NDVI 0.3-0.4

**Ventajas:**
- **Simple**: Solo NDVI + embeddings (ya disponibles)
- **RÃ¡pido**: HeurÃ­sticas eficientes sin training
- **Interpretable**: Clases claras y Ãºtiles
- **Validable**: Cross-validation con Dynamic World

---

## âœ… Criterios de AceptaciÃ³n

### Funcionalidad Core
- [ ] DefiniciÃ³n de taxonomÃ­a de 6 clases LULC
- [ ] Clasificador zero-shot basado en NDVI + embeddings Prithvi
- [ ] ClasificaciÃ³n jerÃ¡rquica: Clase â†’ EstrÃ©s (solo cultivos)
- [ ] Aplicable a segmentaciones MGRG (156 regiones)
- [ ] Mapa semÃ¡ntico coloreado por clase

### MÃ©tricas de DesempeÃ±o
**Resultados esperados:**
- **Cross-validation con Dynamic World**: 70-75% agreement
- **Clases bien separadas**: Water (>90%), Urban (>75%), Crops (>70%)
- **Tiempo de clasificaciÃ³n**: <2s para 150 regiones

### MÃ³dulo Reutilizable
- [ ] `src/classification/zero_shot_classifier.py`:
  - Clase `SemanticClassifier`
  - `classify_region(region_mask)` â†’ class_id, confidence
  - `classify_all_regions(segmentation)` â†’ dict de clasificaciones
  - `generate_semantic_map(segmentation, classifications)` â†’ colored map

### Notebook Demostrativo
- [ ] `notebooks/classification/semantic_classification.ipynb`
- [ ] AplicaciÃ³n a 3 zonas (Mexicali, BajÃ­o, Sinaloa)
- [ ] VisualizaciÃ³n de mapa semÃ¡ntico
- [ ] EstadÃ­sticas: hectÃ¡reas por clase, distribuciÃ³n
- [ ] Cross-validation con Dynamic World

### Testing
- [ ] Tests unitarios: >70% cobertura
  - Test clasificaciÃ³n por NDVI ranges
  - Test con embeddings sintÃ©ticos
  - Test edge cases (regiÃ³n vacÃ­a, single pixel)
  - Test jerarquÃ­a (cultivo â†’ estrÃ©s)

### Cumplimiento AGENTS.md
- [ ] CÃ³digo en inglÃ©s (funciones, variables)
- [ ] DocumentaciÃ³n en espaÃ±ol (narrativa)
- [ ] Type hints en todas las funciones
- [ ] Docstrings estilo Google
- [ ] Sin emojis en cÃ³digo Python
- [ ] Logging profesional

---

## ğŸ—ï¸ Arquitectura de la SoluciÃ³n

### Pipeline de ClasificaciÃ³n

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            PIPELINE DE CLASIFICACIÃ“N SEMÃNTICA                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. INPUTS (De US Anteriores)
   â”‚
   â”œâ”€â”€ SegmentaciÃ³n MGRG: (H, W) con IDs de regiÃ³n [0, N]
   â”œâ”€â”€ Embeddings Prithvi: (H, W, 256) features semÃ¡nticos
   â”œâ”€â”€ NDVI: (H, W) valores [-1, 1]
   â””â”€â”€ RGB (opcional): Para visualizaciÃ³n

2. EXTRACCIÃ“N DE FEATURES POR REGIÃ“N
   â”‚
   â””â”€â”€ Para cada regiÃ³n R:
       â”œâ”€â”€ Crear mÃ¡scara: mask = (segmentation == region_id)
       â”œâ”€â”€ Extraer embeddings: region_embs = embeddings[mask]
       â”œâ”€â”€ Calcular embedding promedio: mean_emb = region_embs.mean(axis=0)
       â”œâ”€â”€ Extraer NDVI: region_ndvi = ndvi[mask]
       â”œâ”€â”€ Calcular NDVI promedio: mean_ndvi = region_ndvi.mean()
       â””â”€â”€ Calcular std NDVI: std_ndvi = region_ndvi.std()

3. CLASIFICACIÃ“N JERÃRQUICA
   â”‚
   â”œâ”€â”€ NIVEL 1: Clase Coarse (basada en NDVI + heurÃ­sticas)
   â”‚   â”‚
   â”‚   â”œâ”€â”€ IF mean_ndvi < 0.1:
   â”‚   â”‚   â”œâ”€â”€ Check embedding similarity to "urban" centroid
   â”‚   â”‚   â”œâ”€â”€ IF similar â†’ Class = Urban (1)
   â”‚   â”‚   â””â”€â”€ ELSE â†’ Class = Water (0)
   â”‚   â”‚
   â”‚   â”œâ”€â”€ ELIF 0.1 â‰¤ mean_ndvi < 0.3:
   â”‚   â”‚   â””â”€â”€ Class = Bare Soil (2)
   â”‚   â”‚
   â”‚   â”œâ”€â”€ ELIF 0.3 â‰¤ mean_ndvi < 0.6:
   â”‚   â”‚   â””â”€â”€ Class = Stressed Crop (4)
   â”‚   â”‚
   â”‚   â””â”€â”€ ELIF mean_ndvi â‰¥ 0.6:
   â”‚       â””â”€â”€ Class = Vigorous Crop (3)
   â”‚
   â””â”€â”€ NIVEL 2: Stress Refinement (solo para cultivos)
       â”‚
       â””â”€â”€ IF Class in [Vigorous Crop, Stressed Crop]:
           â”œâ”€â”€ Bajo EstrÃ©s: 0.5 â‰¤ mean_ndvi < 0.6
           â”œâ”€â”€ Medio EstrÃ©s: 0.4 â‰¤ mean_ndvi < 0.5
           â””â”€â”€ Alto EstrÃ©s: 0.3 â‰¤ mean_ndvi < 0.4

4. GENERACIÃ“N DE MAPA SEMÃNTICO
   â”‚
   â””â”€â”€ semantic_map = np.zeros((H, W), dtype=np.uint8)
       FOR each region_id, classification:
           mask = (segmentation == region_id)
           semantic_map[mask] = classification['class_id']

5. CROSS-VALIDATION (Opcional pero Recomendado)
   â”‚
   â””â”€â”€ IF Dynamic World available:
       â”œâ”€â”€ Load DW mask (aligned)
       â”œâ”€â”€ Map our classes to DW classes:
       â”‚   â”œâ”€â”€ Water (0) â†’ DW Water (0)
       â”‚   â”œâ”€â”€ Urban (1) â†’ DW Built Area (6)
       â”‚   â”œâ”€â”€ Bare Soil (2) â†’ DW Bare Ground (7)
       â”‚   â”œâ”€â”€ Crops (3, 4) â†’ DW Crops (4)
       â”‚   â””â”€â”€ Grass/Shrub (5) â†’ DW Trees/Grass (1, 2)
       â”œâ”€â”€ Calculate agreement per class
       â””â”€â”€ Report overall agreement (target: >70%)

6. VISUALIZACIÃ“N Y REPORTE
   â”‚
   â”œâ”€â”€ Mapa SemÃ¡ntico Coloreado:
   â”‚   â”œâ”€â”€ Water â†’ Blue (#0077BE)
   â”‚   â”œâ”€â”€ Urban â†’ Gray (#808080)
   â”‚   â”œâ”€â”€ Bare Soil â†’ Brown (#8B4513)
   â”‚   â”œâ”€â”€ Vigorous Crop â†’ Dark Green (#228B22)
   â”‚   â”œâ”€â”€ Stressed Crop â†’ Yellow-Green (#9ACD32)
   â”‚   â””â”€â”€ Grass/Shrub â†’ Light Green (#90EE90)
   â”‚
   â”œâ”€â”€ EstadÃ­sticas por Clase:
   â”‚   â””â”€â”€ Tabla: Class | Objects | Area (ha) | Mean NDVI | Std NDVI
   â”‚
   â”œâ”€â”€ DistribuciÃ³n Espacial:
   â”‚   â””â”€â”€ Histogram de NDVI por clase
   â”‚
   â””â”€â”€ Figura para Paper:
       â”œâ”€â”€ Panel 1: RGB original
       â”œâ”€â”€ Panel 2: SegmentaciÃ³n MGRG (regiones anÃ³nimas)
       â”œâ”€â”€ Panel 3: Mapa SemÃ¡ntico (clasificado)
       â””â”€â”€ Panel 4: Dynamic World (referencia)
```

---

## ğŸ’» EspecificaciÃ³n TÃ©cnica

### MÃ³dulo: `src/classification/zero_shot_classifier.py`

```python
"""
Zero-shot semantic classification for segmented regions.

Uses NDVI and Prithvi embeddings to classify land cover types without training.

Supported classes:
    0: Water
    1: Urban / Built Area
    2: Bare Soil / Fallow
    3: Vigorous Crop (NDVI > 0.6)
    4: Stressed Crop (0.3 < NDVI < 0.6)
    5: Grass / Shrub

References:
    - Brown et al. (2022). Dynamic World for validation
    - Muhtar et al. (2024). Prithvi-EO-2.0 embeddings
"""

import numpy as np
from typing import Dict, Tuple, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


# Land cover class definitions
LAND_COVER_CLASSES = {
    0: "Water",
    1: "Urban",
    2: "Bare Soil",
    3: "Vigorous Crop",
    4: "Stressed Crop",
    5: "Grass/Shrub",
}

# Color scheme for visualization (RGB)
CLASS_COLORS = {
    0: (0, 119, 190),      # Blue
    1: (128, 128, 128),    # Gray
    2: (139, 69, 19),      # Brown
    3: (34, 139, 34),      # Dark Green
    4: (154, 205, 50),     # Yellow-Green
    5: (144, 238, 144),    # Light Green
}

# NDVI thresholds for classification
NDVI_THRESHOLDS = {
    'water_urban': 0.1,     # Below this: Water or Urban
    'bare_soil': 0.3,       # 0.1-0.3: Bare Soil
    'stressed_crop': 0.6,   # 0.3-0.6: Stressed Crop
    # Above 0.6: Vigorous Crop
}


@dataclass
class ClassificationResult:
    """
    Result of classifying a single region.

    Attributes
    ----------
    class_id : int
        Predicted class ID (0-5)
    class_name : str
        Human-readable class name
    confidence : float
        Classification confidence [0.0, 1.0]
    mean_ndvi : float
        Mean NDVI of the region
    std_ndvi : float
        Standard deviation of NDVI
    size_pixels : int
        Number of pixels in region
    area_hectares : float
        Area in hectares (assuming 10m resolution)
    """
    class_id: int
    class_name: str
    confidence: float
    mean_ndvi: float
    std_ndvi: float
    size_pixels: int
    area_hectares: float


class SemanticClassifier:
    """
    Zero-shot semantic classifier for land cover.

    Uses hierarchical classification:
        Level 1: Coarse class (Water, Urban, Crops, etc.)
        Level 2: Stress analysis (only for crops)

    Parameters
    ----------
    embeddings : np.ndarray
        Prithvi embeddings (H, W, 256)
    ndvi : np.ndarray
        NDVI array (H, W) with values in [-1, 1]
    resolution : float, default=10.0
        Spatial resolution in meters (for area calculation)

    Examples
    --------
    >>> embeddings = np.load('embeddings.npy')  # (1124, 922, 256)
    >>> ndvi = np.load('ndvi.npy')  # (1124, 922)
    >>> segmentation = np.load('mgrg_seg.npy')  # (1124, 922)
    >>>
    >>> classifier = SemanticClassifier(embeddings, ndvi)
    >>> results = classifier.classify_all_regions(segmentation)
    >>>
    >>> # Access classification for region 5
    >>> print(results[5].class_name)
    'Vigorous Crop'
    >>> print(f"Area: {results[5].area_hectares:.1f} ha")
    Area: 124.5 ha
    """

    def __init__(
        self,
        embeddings: np.ndarray,
        ndvi: np.ndarray,
        resolution: float = 10.0
    ):
        assert embeddings.shape[:2] == ndvi.shape, \
            f"Shape mismatch: embeddings {embeddings.shape[:2]} vs ndvi {ndvi.shape}"

        self.embeddings = embeddings
        self.ndvi = ndvi
        self.resolution = resolution
        self.h, self.w = ndvi.shape

        logger.info(f"SemanticClassifier initialized. Shape: {self.h}x{self.w}, "
                   f"Resolution: {resolution}m")

    def classify_region(self, region_mask: np.ndarray) -> ClassificationResult:
        """
        Classify a single region using hierarchical approach.

        Parameters
        ----------
        region_mask : np.ndarray
            Binary mask (H, W) where True indicates pixels in region

        Returns
        -------
        ClassificationResult
            Classification with class, confidence, and statistics

        Examples
        --------
        >>> mask = (segmentation == 45)
        >>> result = classifier.classify_region(mask)
        >>> print(f"{result.class_name}: {result.confidence:.2f}")
        Vigorous Crop: 0.87
        """
        assert region_mask.shape == self.ndvi.shape, "Mask shape mismatch"
        assert region_mask.dtype == bool, "Mask must be boolean"

        # Extract region statistics
        region_ndvi = self.ndvi[region_mask]
        region_embs = self.embeddings[region_mask]

        mean_ndvi = float(region_ndvi.mean())
        std_ndvi = float(region_ndvi.std())
        size_pixels = int(region_mask.sum())

        # Calculate area (resolution in meters)
        area_m2 = size_pixels * (self.resolution ** 2)
        area_hectares = area_m2 / 10000.0  # mÂ² to hectares

        # Level 1: Coarse classification based on NDVI
        class_id, confidence = self._classify_coarse(
            mean_ndvi, std_ndvi, region_embs
        )

        class_name = LAND_COVER_CLASSES[class_id]

        return ClassificationResult(
            class_id=class_id,
            class_name=class_name,
            confidence=confidence,
            mean_ndvi=mean_ndvi,
            std_ndvi=std_ndvi,
            size_pixels=size_pixels,
            area_hectares=area_hectares
        )

    def _classify_coarse(
        self,
        mean_ndvi: float,
        std_ndvi: float,
        embeddings: np.ndarray
    ) -> Tuple[int, float]:
        """
        Classify into coarse categories using NDVI thresholds.

        Returns
        -------
        class_id : int
            Predicted class (0-5)
        confidence : float
            Classification confidence [0.0, 1.0]
        """
        # Very low NDVI: Water or Urban
        if mean_ndvi < NDVI_THRESHOLDS['water_urban']:
            # Distinguish Water vs Urban using embedding similarity
            # Simple heuristic: Urban has higher variability
            if std_ndvi > 0.05:  # Urban areas have more variation
                return 1, 0.75  # Urban
            else:
                return 0, 0.85  # Water

        # Low NDVI: Bare Soil
        elif mean_ndvi < NDVI_THRESHOLDS['bare_soil']:
            confidence = 1.0 - abs(mean_ndvi - 0.2) / 0.2  # Peak at 0.2
            return 2, max(0.6, confidence)  # Bare Soil

        # Medium NDVI: Stressed Crop
        elif mean_ndvi < NDVI_THRESHOLDS['stressed_crop']:
            confidence = 1.0 - abs(mean_ndvi - 0.45) / 0.15  # Peak at 0.45
            return 4, max(0.65, confidence)  # Stressed Crop

        # High NDVI: Vigorous Crop or Grass/Shrub
        else:
            # Crops typically have std_ndvi < 0.1 (uniform fields)
            # Natural vegetation has higher variability
            if std_ndvi < 0.1:
                confidence = 0.85 + (mean_ndvi - 0.6) * 0.25  # Higher for NDVI~0.8
                return 3, min(0.95, confidence)  # Vigorous Crop
            else:
                return 5, 0.70  # Grass/Shrub

    def classify_all_regions(
        self,
        segmentation: np.ndarray,
        min_size: int = 10
    ) -> Dict[int, ClassificationResult]:
        """
        Classify all regions in a segmentation.

        Parameters
        ----------
        segmentation : np.ndarray
            Segmentation mask (H, W) with integer region IDs
        min_size : int, default=10
            Skip regions smaller than this (pixels)

        Returns
        -------
        dict
            Mapping region_id -> ClassificationResult

        Examples
        --------
        >>> results = classifier.classify_all_regions(mgrg_seg)
        >>> print(f"Classified {len(results)} regions")
        Classified 156 regions
        """
        assert segmentation.shape == self.ndvi.shape, "Segmentation shape mismatch"

        region_ids = np.unique(segmentation)
        region_ids = region_ids[region_ids != 0]  # Exclude background

        logger.info(f"Classifying {len(region_ids)} regions...")

        results = {}
        skipped = 0

        for region_id in region_ids:
            mask = (segmentation == region_id)

            # Skip small regions
            if mask.sum() < min_size:
                skipped += 1
                continue

            result = self.classify_region(mask)
            results[int(region_id)] = result

        logger.info(f"Classification complete. {len(results)} regions classified, "
                   f"{skipped} skipped (too small)")

        return results

    def generate_semantic_map(
        self,
        segmentation: np.ndarray,
        classifications: Dict[int, ClassificationResult]
    ) -> np.ndarray:
        """
        Generate semantic map from segmentation and classifications.

        Parameters
        ----------
        segmentation : np.ndarray
            Segmentation mask (H, W)
        classifications : dict
            Region classifications from classify_all_regions()

        Returns
        -------
        np.ndarray
            Semantic map (H, W) with class IDs (0-5)

        Examples
        --------
        >>> semantic_map = classifier.generate_semantic_map(
        ...     segmentation, classifications
        ... )
        >>> plt.imshow(semantic_map, cmap='tab10')
        """
        semantic_map = np.zeros(segmentation.shape, dtype=np.uint8)

        for region_id, result in classifications.items():
            mask = (segmentation == region_id)
            semantic_map[mask] = result.class_id

        logger.info(f"Semantic map generated. Shape: {semantic_map.shape}")
        return semantic_map

    def generate_colored_map(
        self,
        semantic_map: np.ndarray
    ) -> np.ndarray:
        """
        Generate RGB colored map from semantic map.

        Parameters
        ----------
        semantic_map : np.ndarray
            Semantic map (H, W) with class IDs

        Returns
        -------
        np.ndarray
            RGB image (H, W, 3) with class colors
        """
        h, w = semantic_map.shape
        colored_map = np.zeros((h, w, 3), dtype=np.uint8)

        for class_id, color in CLASS_COLORS.items():
            mask = (semantic_map == class_id)
            colored_map[mask] = color

        return colored_map

    def get_class_statistics(
        self,
        classifications: Dict[int, ClassificationResult]
    ) -> Dict[str, Dict]:
        """
        Calculate statistics per class.

        Returns
        -------
        dict
            Statistics per class: count, total_area, mean_ndvi, etc.

        Examples
        --------
        >>> stats = classifier.get_class_statistics(classifications)
        >>> print(stats['Vigorous Crop'])
        {'count': 67, 'area_ha': 1245.8, 'mean_ndvi': 0.72, ...}
        """
        stats = {name: {
            'count': 0,
            'area_ha': 0.0,
            'mean_ndvi': [],
        } for name in LAND_COVER_CLASSES.values()}

        for result in classifications.values():
            class_name = result.class_name
            stats[class_name]['count'] += 1
            stats[class_name]['area_ha'] += result.area_hectares
            stats[class_name]['mean_ndvi'].append(result.mean_ndvi)

        # Calculate mean NDVI per class
        for class_name in stats:
            if stats[class_name]['mean_ndvi']:
                ndvi_values = stats[class_name]['mean_ndvi']
                stats[class_name]['mean_ndvi'] = float(np.mean(ndvi_values))
                stats[class_name]['std_ndvi'] = float(np.std(ndvi_values))
            else:
                stats[class_name]['mean_ndvi'] = 0.0
                stats[class_name]['std_ndvi'] = 0.0

        return stats


def cross_validate_with_dynamic_world(
    our_semantic_map: np.ndarray,
    dynamic_world_mask: np.ndarray
) -> Dict[str, float]:
    """
    Cross-validate our classification against Dynamic World.

    Maps our classes to Dynamic World classes and calculates agreement.

    Parameters
    ----------
    our_semantic_map : np.ndarray
        Our semantic map (H, W) with class IDs 0-5
    dynamic_world_mask : np.ndarray
        Dynamic World mask (H, W) with DW class IDs 0-8

    Returns
    -------
    dict
        Agreement per class and overall agreement

    Examples
    --------
    >>> agreements = cross_validate_with_dynamic_world(
    ...     semantic_map, dw_mask
    ... )
    >>> print(f"Overall agreement: {agreements['overall']:.1%}")
    Overall agreement: 73.4%
    """
    # Mapping: Our classes â†’ Dynamic World classes
    class_mapping = {
        0: [0],           # Water â†’ Water
        1: [6],           # Urban â†’ Built Area
        2: [7],           # Bare Soil â†’ Bare Ground
        3: [4],           # Vigorous Crop â†’ Crops
        4: [4],           # Stressed Crop â†’ Crops
        5: [1, 2, 3],     # Grass/Shrub â†’ Trees/Grass/Flooded Veg
    }

    agreements = {}
    total_correct = 0
    total_pixels = 0

    for our_class_id, dw_class_ids in class_mapping.items():
        our_mask = (our_semantic_map == our_class_id)
        dw_mask = np.isin(dynamic_world_mask, dw_class_ids)

        if our_mask.sum() == 0:
            agreements[LAND_COVER_CLASSES[our_class_id]] = 0.0
            continue

        correct = np.logical_and(our_mask, dw_mask).sum()
        total = our_mask.sum()

        agreement = correct / total
        agreements[LAND_COVER_CLASSES[our_class_id]] = float(agreement)

        total_correct += correct
        total_pixels += total

    # Overall agreement
    agreements['overall'] = total_correct / total_pixels if total_pixels > 0 else 0.0

    return agreements
```

### Notebook: `notebooks/classification/semantic_classification.ipynb`

**Estructura del Notebook:**

```markdown
# ClasificaciÃ³n SemÃ¡ntica de Objetos Post-SegmentaciÃ³n

## 1. Setup e Imports
- Imports de librerÃ­as
- ConfiguraciÃ³n de paths
- Carga de funciones de src/classification/

## 2. Carga de Datos

### 2.1 Datos de Entrada (Mexicali)
- SegmentaciÃ³n MGRG (156 regiones)
- Embeddings Prithvi (256D)
- NDVI
- RGB para visualizaciÃ³n

### 2.2 ExploraciÃ³n Inicial
- DistribuciÃ³n de NDVI
- Histograma de tamaÃ±os de regiones
- VisualizaciÃ³n de segmentaciÃ³n

## 3. ClasificaciÃ³n Zero-Shot

### 3.1 Inicializar Clasificador
classifier = SemanticClassifier(embeddings, ndvi, resolution=10.0)

### 3.2 Clasificar Todas las Regiones
classifications = classifier.classify_all_regions(mgrg_seg)

### 3.3 Resultados por RegiÃ³n (Ejemplo)
Region 5:
  Class: Vigorous Crop
  Confidence: 0.87
  Mean NDVI: 0.72
  Area: 124.5 ha

## 4. GeneraciÃ³n de Mapa SemÃ¡ntico

### 4.1 Crear Mapa de Clases
semantic_map = classifier.generate_semantic_map(mgrg_seg, classifications)

### 4.2 Mapa Coloreado
colored_map = classifier.generate_colored_map(semantic_map)

### 4.3 VisualizaciÃ³n Comparativa
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RGB Original â”‚ MGRG Seg     â”‚ Semantic Map â”‚
â”‚              â”‚ (anÃ³nimo)    â”‚ (clasificado)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 5. EstadÃ­sticas por Clase

### 5.1 Resumen Cuantitativo
=== Semantic Classification Results (Mexicali) ===
Water               :   8 objects (  45.2 ha, NDVI: 0.05)
Urban               :  12 objects (  89.7 ha, NDVI: 0.12)
Bare Soil           :  23 objects ( 156.3 ha, NDVI: 0.22)
Vigorous Crop       :  67 objects (1245.8 ha, NDVI: 0.72)
Stressed Crop       :  38 objects ( 523.1 ha, NDVI: 0.45)
Grass/Shrub         :   8 objects (  67.4 ha, NDVI: 0.65)

### 5.2 GrÃ¡ficos
- Barplot: Ãrea por clase (hectÃ¡reas)
- Pie chart: ProporciÃ³n de clases
- Boxplot: DistribuciÃ³n de NDVI por clase

## 6. Cross-Validation con Dynamic World

### 6.1 Cargar Dynamic World Mask
dw_mask = np.load('data/dynamic_world/mexicali_dw.npy')

### 6.2 Calcular Agreement
agreements = cross_validate_with_dynamic_world(semantic_map, dw_mask)

### 6.3 Resultados
=== Cross-Validation with Dynamic World ===
Water               : 92.3% agreement
Urban               : 78.5% agreement
Bare Soil           : 65.2% agreement
Vigorous Crop       : 74.1% agreement
Stressed Crop       : 69.5% agreement
Grass/Shrub         : 59.4% agreement

Mean Agreement      : 73.4% âœ… (Target: >70%)

### 6.4 DiscusiÃ³n
- Alta concordancia en Water (92%) - clase bien definida
- Urban moderada (78%) - confusiÃ³n con Bare Soil
- Crops acceptable (70-74%) - Dynamic World no distingue estrÃ©s
- Grass/Shrub baja (59%) - lÃ­mites ambiguos con crops

## 7. AnÃ¡lisis por Zona

### 7.1 Repetir para BajÃ­o
- Similar anÃ¡lisis
- Comparar distribuciÃ³n de clases

### 7.2 Repetir para Sinaloa
- Similar anÃ¡lisis
- Validar consistencia

### 7.3 ComparaciÃ³n Agregada
Tabla: Zona | Vigorous Crop (ha) | Stressed Crop (ha) | Water (ha) | ...

## 8. AnÃ¡lisis JerÃ¡rquico (Clase â†’ EstrÃ©s)

### 8.1 Filtrar Solo Cultivos
crop_regions = [r for r in classifications.values()
                if r.class_id in [3, 4]]

### 8.2 Sub-ClasificaciÃ³n de EstrÃ©s
Bajo EstrÃ©s  : 25 regions (450 ha)
Medio EstrÃ©s : 32 regions (680 ha)
Alto EstrÃ©s  : 48 regions (638 ha)

### 8.3 Mapa de Calor de EstrÃ©s
- Solo cultivos
- Gradiente verde â†’ amarillo â†’ rojo

## 9. VisualizaciÃ³n para Paper

### 9.1 Figura Multi-Panel (300 DPI)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RGB Original â”‚ Segmentation â”‚ Dynamic      â”‚
â”‚              â”‚ (MGRG)       â”‚ World (GT)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Semantic     â”‚ Stress Map   â”‚ Legend       â”‚
â”‚ Map (Ours)   â”‚ (Crops only) â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 9.2 Tabla de ClasificaciÃ³n (LaTeX)
| Class | Objects | Area (ha) | % Total | Mean NDVI | Agreement DW |
|-------|---------|-----------|---------|-----------|--------------|
| Water | 8 | 45.2 | 2.2% | 0.05 | 92.3% |
| Urban | 12 | 89.7 | 4.3% | 0.12 | 78.5% |
| ... | ... | ... | ... | ... | ... |

## 10. Conclusiones

1. ClasificaciÃ³n zero-shot logra 73% agreement con Dynamic World
2. JerarquÃ­a Clase â†’ EstrÃ©s corrige problema de US-008
3. Mapas semÃ¡nticos mÃ¡s interpretables que regiones anÃ³nimas
4. Cultivos correctamente separados de urbano y suelo desnudo
5. Futuro: Fine-tuning con few-shot learning (20-30 ejemplos)
```

---

## ğŸ“Š Plan de Desarrollo (8 horas)

### Fase 1: ImplementaciÃ³n del Clasificador (3 horas)

#### 1.1 Clase SemanticClassifier Base (1.5h)
**Archivos**: `src/classification/zero_shot_classifier.py`

**Tareas**:
- [ ] Definir constantes globales (LAND_COVER_CLASSES, CLASS_COLORS, NDVI_THRESHOLDS)
- [ ] Implementar dataclass `ClassificationResult` con type hints
- [ ] Implementar `__init__()` con validaciÃ³n de shapes
- [ ] Implementar `classify_region()` con heurÃ­sticas NDVI
- [ ] Implementar `_classify_coarse()` con lÃ³gica de decisiÃ³n
- [ ] Implementar `classify_all_regions()` con loop y filtrado
- [ ] Implementar `generate_semantic_map()` para mapeo de clases
- [ ] Implementar `generate_colored_map()` para visualizaciÃ³n RGB
- [ ] Implementar `get_class_statistics()` para anÃ¡lisis agregado
- [ ] Logging profesional (logger, no print)

**Criterios de Ã©xito**:
- CÃ³digo en inglÃ©s, docstrings estilo Google
- Type hints en todas las funciones
- Manejo de edge cases (regiones vacÃ­as, single pixel)
- Sin emojis en cÃ³digo

#### 1.2 FunciÃ³n de Cross-Validation (1h)
**Archivos**: `src/classification/zero_shot_classifier.py`

**Tareas**:
- [ ] Implementar `cross_validate_with_dynamic_world()`
- [ ] Definir mapeo de clases: Our â†’ Dynamic World
- [ ] Calcular agreement por clase
- [ ] Calcular agreement global
- [ ] Retornar diccionario con resultados

**Criterios de Ã©xito**:
- Mapeo correcto de clases (Waterâ†’0, Urbanâ†’6, Cropsâ†’4, etc.)
- Manejo de clases sin datos
- DocumentaciÃ³n clara del mapeo

#### 1.3 OptimizaciÃ³n y Refinamiento (30 min)
**Tareas**:
- [ ] Revisar complejidad temporal (debe ser O(n) para classify_all_regions)
- [ ] Optimizar cÃ¡lculos con NumPy vectorizado
- [ ] Agregar validaciones de entrada
- [ ] Verificar normalizaciÃ³n de embeddings

### Fase 2: Testing Exhaustivo (2 horas)

#### 2.1 Tests Unitarios (1.5h)
**Archivos**: `tests/unit/test_zero_shot_classifier.py`

**Estructura de tests** (mÃ­nimo 20 tests):

**Clase TestInitialization** (4 tests):
- [ ] test_initialization_valid_inputs
- [ ] test_initialization_shape_mismatch
- [ ] test_initialization_resolution_parameter
- [ ] test_initialization_logging

**Clase TestClassifyRegion** (6 tests):
- [ ] test_classify_water_low_ndvi_low_std
- [ ] test_classify_urban_low_ndvi_high_std
- [ ] test_classify_bare_soil_medium_ndvi
- [ ] test_classify_stressed_crop_medium_high_ndvi
- [ ] test_classify_vigorous_crop_high_ndvi_low_std
- [ ] test_classify_grass_shrub_high_ndvi_high_std

**Clase TestClassifyAllRegions** (4 tests):
- [ ] test_classify_all_regions_basic
- [ ] test_classify_all_regions_with_min_size_filter
- [ ] test_classify_all_regions_empty_segmentation
- [ ] test_classify_all_regions_large_dataset

**Clase TestSemanticMap** (3 tests):
- [ ] test_generate_semantic_map_basic
- [ ] test_generate_colored_map_rgb_output
- [ ] test_semantic_map_shape_consistency

**Clase TestStatistics** (3 tests):
- [ ] test_get_class_statistics_basic
- [ ] test_get_class_statistics_empty_class
- [ ] test_get_class_statistics_aggregation

**Criterios de Ã©xito**:
- Cobertura >70% (objetivo: 80%+)
- Todos los tests pasan
- Tests rÃ¡pidos (<5s total)
- Uso de fixtures para datos sintÃ©ticos

#### 2.2 Tests de IntegraciÃ³n (30 min)
**Archivos**: `tests/integration/test_classification_workflow.py`

**Tests** (mÃ­nimo 3):
- [ ] test_end_to_end_classification_workflow
- [ ] test_classification_with_real_embeddings
- [ ] test_cross_validation_workflow

**Criterios de Ã©xito**:
- Usa datos reales (embeddings de Mexicali)
- Verifica consistencia de resultados
- Tiempo de ejecuciÃ³n <30s

### Fase 3: Notebook Demostrativo (2 horas)

#### 3.1 Estructura del Notebook (1h)
**Archivos**: `notebooks/classification/semantic_classification.ipynb`

**Secciones** (siguiendo estÃ¡ndar US-007/008):

1. **Setup e Imports** (1 celda)
   - Imports de librerÃ­as
   - ConfiguraciÃ³n de paths
   - Carga de funciones de src/

2. **Carga de Datos** (2 celdas)
   - Cargar segmentaciÃ³n MGRG (156 regiones)
   - Cargar embeddings Prithvi (256D)
   - Cargar NDVI y RGB

3. **ClasificaciÃ³n Zero-Shot** (3 celdas)
   - Inicializar SemanticClassifier
   - Clasificar todas las regiones
   - Mostrar resultados de ejemplo (5 regiones)

4. **GeneraciÃ³n de Mapa SemÃ¡ntico** (2 celdas)
   - Crear mapa de clases
   - Crear mapa coloreado RGB
   - VisualizaciÃ³n comparativa (RGB | MGRG | Semantic)

5. **EstadÃ­sticas por Clase** (3 celdas)
   - Tabla resumen cuantitativo
   - Barplot: Ãrea por clase (hectÃ¡reas)
   - Boxplot: DistribuciÃ³n de NDVI por clase

6. **Cross-Validation con Dynamic World** (3 celdas)
   - Cargar Dynamic World mask
   - Calcular agreements
   - AnÃ¡lisis de discrepancias

7. **AnÃ¡lisis JerÃ¡rquico** (2 celdas)
   - Filtrar solo cultivos
   - Sub-clasificaciÃ³n de estrÃ©s (bajo/medio/alto)
   - Mapa de calor de estrÃ©s

8. **Conclusiones** (1 celda)
   - Resumen de resultados
   - InterpretaciÃ³n de mÃ©tricas
   - Recomendaciones

**Criterios de Ã©xito**:
- Texto explicativo en espaÃ±ol
- CÃ³digo en inglÃ©s
- Sin emojis en cÃ³digo Python
- Visualizaciones profesionales (300 DPI)
- Resultados reproducibles

#### 3.2 AplicaciÃ³n a 3 Zonas (1h)
**Tareas**:
- [ ] Repetir anÃ¡lisis para Mexicali
- [ ] Repetir anÃ¡lisis para BajÃ­o
- [ ] Repetir anÃ¡lisis para Sinaloa
- [ ] Tabla comparativa agregada

**Criterios de Ã©xito**:
- Consistencia de resultados entre zonas
- IdentificaciÃ³n de patrones regionales
- DocumentaciÃ³n de diferencias

### Fase 4: DocumentaciÃ³n y Refinamiento (1 hora)

#### 4.1 README Actualizado (30 min)
**Archivos**: `README.md`

**Secciones a agregar**:
- [ ] TÃ­tulo: "US-010: ClasificaciÃ³n SemÃ¡ntica de Objetos"
- [ ] DescripciÃ³n del problema y soluciÃ³n
- [ ] TaxonomÃ­a de 6 clases LULC
- [ ] Ejemplos de uso con cÃ³digo
- [ ] InterpretaciÃ³n de resultados
- [ ] Tabla de mÃ©tricas tÃ­picas
- [ ] Referencias acadÃ©micas

**Criterios de Ã©xito**:
- SecciÃ³n completa (80-100 lÃ­neas)
- Ejemplos ejecutables
- Formato consistente con US-007/008

#### 4.2 ResoluciÃ³n de US (30 min)
**Archivos**: `docs/us-resolved/us-010.md`

**Estructura** (siguiendo template US-007/008):
- [ ] Resumen ejecutivo
- [ ] Criterios de aceptaciÃ³n cumplidos
- [ ] ImplementaciÃ³n realizada (archivos creados/modificados)
- [ ] Resultados experimentales (tabla de mÃ©tricas)
- [ ] MÃ©tricas de calidad (cobertura de tests)
- [ ] Hallazgos clave y lecciones aprendidas
- [ ] Trabajo futuro
- [ ] Referencias implementadas
- [ ] ConclusiÃ³n final
- [ ] Checklist final

**Criterios de Ã©xito**:
- DocumentaciÃ³n completa y profesional
- AnÃ¡lisis cuantitativo de resultados
- Lecciones aprendidas documentadas
- Formato consistente con US anteriores

---

## ğŸ§ª EspecificaciÃ³n de Testing (>70% cobertura)

### Estructura de Tests

```
tests/
â”œâ”€â”€ unit/
â”‚   â””â”€â”€ test_zero_shot_classifier.py    # 20+ tests unitarios
â””â”€â”€ integration/
    â””â”€â”€ test_classification_workflow.py  # 3+ tests de integraciÃ³n
```

### Tests Unitarios Detallados

**Archivo**: `tests/unit/test_zero_shot_classifier.py`
**Objetivo**: >70% cobertura (meta: 80%+)
**Total tests**: 20 mÃ­nimo

#### Clase TestInitialization (4 tests)

```python
class TestInitialization:
    """Tests for SemanticClassifier initialization"""

    def test_initialization_valid_inputs(self):
        """Should initialize with valid embeddings and NDVI"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi)
        
        assert classifier.h == 100
        assert classifier.w == 100
        assert classifier.resolution == 10.0

    def test_initialization_shape_mismatch(self):
        """Should raise AssertionError on shape mismatch"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(50, 50)  # Different shape
        
        with pytest.raises(AssertionError):
            SemanticClassifier(embeddings, ndvi)

    def test_initialization_resolution_parameter(self):
        """Should accept custom resolution"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi, resolution=20.0)
        
        assert classifier.resolution == 20.0

    def test_initialization_logging(self, caplog):
        """Should log initialization message"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        
        with caplog.at_level(logging.INFO):
            SemanticClassifier(embeddings, ndvi)
        
        assert "SemanticClassifier initialized" in caplog.text
```

#### Clase TestClassifyRegion (6 tests)

```python
class TestClassifyRegion:
    """Tests for classify_region() method"""

    def test_classify_water_low_ndvi_low_std(self):
        """Should classify low NDVI with low std as Water"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.ones((100, 100)) * 0.05  # Very low NDVI
        classifier = SemanticClassifier(embeddings, ndvi)

        mask = np.ones((100, 100), dtype=bool)
        result = classifier.classify_region(mask)

        assert result.class_id == 0  # Water
        assert result.class_name == "Water"
        assert result.confidence > 0.8

    def test_classify_urban_low_ndvi_high_std(self):
        """Should classify low NDVI with high std as Urban"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100) * 0.1  # Low NDVI, high variation
        classifier = SemanticClassifier(embeddings, ndvi)

        mask = np.ones((100, 100), dtype=bool)
        result = classifier.classify_region(mask)

        assert result.class_id == 1  # Urban
        assert result.class_name == "Urban"

    def test_classify_bare_soil_medium_ndvi(self):
        """Should classify medium NDVI (0.1-0.3) as Bare Soil"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.ones((100, 100)) * 0.2
        classifier = SemanticClassifier(embeddings, ndvi)

        mask = np.ones((100, 100), dtype=bool)
        result = classifier.classify_region(mask)

        assert result.class_id == 2  # Bare Soil
        assert result.class_name == "Bare Soil"

    def test_classify_stressed_crop_medium_high_ndvi(self):
        """Should classify NDVI 0.3-0.6 as Stressed Crop"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.ones((100, 100)) * 0.45
        classifier = SemanticClassifier(embeddings, ndvi)

        mask = np.ones((100, 100), dtype=bool)
        result = classifier.classify_region(mask)

        assert result.class_id == 4  # Stressed Crop
        assert result.class_name == "Stressed Crop"

    def test_classify_vigorous_crop_high_ndvi_low_std(self):
        """Should classify NDVI >0.6 with low std as Vigorous Crop"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.ones((100, 100)) * 0.75  # High NDVI, uniform
        classifier = SemanticClassifier(embeddings, ndvi)

        mask = np.ones((100, 100), dtype=bool)
        result = classifier.classify_region(mask)

        assert result.class_id == 3  # Vigorous Crop
        assert result.class_name == "Vigorous Crop"

    def test_classify_grass_shrub_high_ndvi_high_std(self):
        """Should classify NDVI >0.6 with high std as Grass/Shrub"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100) * 0.4 + 0.6  # High NDVI, variable
        classifier = SemanticClassifier(embeddings, ndvi)

        mask = np.ones((100, 100), dtype=bool)
        result = classifier.classify_region(mask)

        assert result.class_id == 5  # Grass/Shrub
        assert result.class_name == "Grass/Shrub"
```

#### Clase TestClassifyAllRegions (4 tests)

```python
class TestClassifyAllRegions:
    """Tests for classify_all_regions() method"""

    def test_classify_all_regions_basic(self):
        """Should classify all regions in segmentation"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi)

        segmentation = np.zeros((100, 100), dtype=np.int32)
        segmentation[0:50, 0:50] = 1
        segmentation[50:100, 50:100] = 2

        results = classifier.classify_all_regions(segmentation)

        assert len(results) == 2
        assert 1 in results
        assert 2 in results

    def test_classify_all_regions_with_min_size_filter(self):
        """Should skip regions smaller than min_size"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi)

        segmentation = np.zeros((100, 100), dtype=np.int32)
        segmentation[0:10, 0:10] = 1  # 100 pixels (>50)
        segmentation[0:5, 0:5] = 2    # 25 pixels (<50)

        results = classifier.classify_all_regions(segmentation, min_size=50)

        assert len(results) == 1
        assert 1 in results
        assert 2 not in results

    def test_classify_all_regions_empty_segmentation(self):
        """Should handle empty segmentation (all zeros)"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi)

        segmentation = np.zeros((100, 100), dtype=np.int32)

        results = classifier.classify_all_regions(segmentation)

        assert len(results) == 0

    def test_classify_all_regions_large_dataset(self):
        """Should handle large segmentation efficiently"""
        embeddings = np.random.rand(1000, 1000, 256)
        ndvi = np.random.rand(1000, 1000)
        classifier = SemanticClassifier(embeddings, ndvi)

        segmentation = np.random.randint(0, 100, (1000, 1000), dtype=np.int32)

        import time
        start = time.time()
        results = classifier.classify_all_regions(segmentation)
        elapsed = time.time() - start

        assert elapsed < 5.0  # Should complete in <5s
        assert len(results) > 0
```

#### Clase TestSemanticMap (3 tests)

```python
class TestSemanticMap:
    """Tests for semantic map generation"""

    def test_generate_semantic_map_basic(self):
        """Should generate semantic map with correct class IDs"""
        embeddings = np.random.rand(50, 50, 256)
        ndvi = np.random.rand(50, 50)
        classifier = SemanticClassifier(embeddings, ndvi)

        segmentation = np.zeros((50, 50), dtype=np.int32)
        segmentation[10:20, 10:20] = 1

        results = classifier.classify_all_regions(segmentation)
        semantic_map = classifier.generate_semantic_map(segmentation, results)

        assert semantic_map.shape == (50, 50)
        assert semantic_map.dtype == np.uint8
        assert semantic_map.max() <= 5

    def test_generate_colored_map_rgb_output(self):
        """Should generate RGB colored map"""
        embeddings = np.random.rand(50, 50, 256)
        ndvi = np.random.rand(50, 50)
        classifier = SemanticClassifier(embeddings, ndvi)

        semantic_map = np.zeros((50, 50), dtype=np.uint8)
        semantic_map[10:20, 10:20] = 3  # Vigorous Crop

        colored_map = classifier.generate_colored_map(semantic_map)

        assert colored_map.shape == (50, 50, 3)
        assert colored_map.dtype == np.uint8
        assert np.any(colored_map > 0)

    def test_semantic_map_shape_consistency(self):
        """Should maintain shape consistency throughout pipeline"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi)

        segmentation = np.random.randint(0, 10, (100, 100), dtype=np.int32)
        results = classifier.classify_all_regions(segmentation)
        semantic_map = classifier.generate_semantic_map(segmentation, results)
        colored_map = classifier.generate_colored_map(semantic_map)

        assert segmentation.shape == semantic_map.shape
        assert semantic_map.shape[:2] == colored_map.shape[:2]
```

#### Clase TestStatistics (3 tests)

```python
class TestStatistics:
    """Tests for get_class_statistics() method"""

    def test_get_class_statistics_basic(self):
        """Should calculate statistics per class"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi)

        # Create mock classifications
        classifications = {
            1: ClassificationResult(3, "Vigorous Crop", 0.9, 0.75, 0.05, 1000, 1.0),
            2: ClassificationResult(4, "Stressed Crop", 0.8, 0.45, 0.08, 500, 0.5),
        }

        stats = classifier.get_class_statistics(classifications)

        assert "Vigorous Crop" in stats
        assert "Stressed Crop" in stats
        assert stats["Vigorous Crop"]["count"] == 1
        assert stats["Vigorous Crop"]["area_ha"] == 1.0

    def test_get_class_statistics_empty_class(self):
        """Should handle classes with no regions"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi)

        classifications = {}
        stats = classifier.get_class_statistics(classifications)

        assert "Water" in stats
        assert stats["Water"]["count"] == 0
        assert stats["Water"]["area_ha"] == 0.0

    def test_get_class_statistics_aggregation(self):
        """Should aggregate statistics correctly"""
        embeddings = np.random.rand(100, 100, 256)
        ndvi = np.random.rand(100, 100)
        classifier = SemanticClassifier(embeddings, ndvi)

        classifications = {
            1: ClassificationResult(3, "Vigorous Crop", 0.9, 0.75, 0.05, 1000, 1.0),
            2: ClassificationResult(3, "Vigorous Crop", 0.85, 0.72, 0.06, 800, 0.8),
        }

        stats = classifier.get_class_statistics(classifications)

        assert stats["Vigorous Crop"]["count"] == 2
        assert stats["Vigorous Crop"]["area_ha"] == 1.8
        assert 0.73 < stats["Vigorous Crop"]["mean_ndvi"] < 0.74
```

### Tests de IntegraciÃ³n

**Archivo**: `tests/integration/test_classification_workflow.py`
**Total tests**: 3 mÃ­nimo

```python
class TestClassificationWorkflow:
    """Integration tests for complete classification workflow"""

    def test_end_to_end_classification_workflow(self):
        """Should complete full workflow from data to visualization"""
        # Load real data
        embeddings = np.load("data/embeddings/mexicali_embeddings.npy")
        ndvi = np.load("data/ndvi/mexicali_ndvi.npy")
        segmentation = np.load("data/segmentation/mexicali_mgrg.npy")

        # Classify
        classifier = SemanticClassifier(embeddings, ndvi)
        results = classifier.classify_all_regions(segmentation)

        # Generate maps
        semantic_map = classifier.generate_semantic_map(segmentation, results)
        colored_map = classifier.generate_colored_map(semantic_map)

        # Statistics
        stats = classifier.get_class_statistics(results)

        # Assertions
        assert len(results) > 0
        assert semantic_map.shape == segmentation.shape
        assert colored_map.shape == (*segmentation.shape, 3)
        assert len(stats) == 6

    def test_classification_with_real_embeddings(self):
        """Should produce consistent results with real embeddings"""
        embeddings = np.load("data/embeddings/mexicali_embeddings.npy")
        ndvi = np.load("data/ndvi/mexicali_ndvi.npy")
        segmentation = np.load("data/segmentation/mexicali_mgrg.npy")

        classifier = SemanticClassifier(embeddings, ndvi)
        results1 = classifier.classify_all_regions(segmentation)
        results2 = classifier.classify_all_regions(segmentation)

        # Results should be deterministic
        assert len(results1) == len(results2)
        for region_id in results1:
            assert results1[region_id].class_id == results2[region_id].class_id

    def test_cross_validation_workflow(self):
        """Should complete cross-validation with Dynamic World"""
        semantic_map = np.load("data/semantic_maps/mexicali_semantic.npy")
        dw_mask = np.load("data/dynamic_world/mexicali_dw.npy")

        agreements = cross_validate_with_dynamic_world(semantic_map, dw_mask)

        assert "overall" in agreements
        assert agreements["overall"] > 0.0
        assert agreements["overall"] <= 1.0
        assert "Water" in agreements
```

### Comandos de EjecuciÃ³n

```bash
# Ejecutar todos los tests
poetry run pytest tests/unit/test_zero_shot_classifier.py -v

# Ejecutar con cobertura
poetry run pytest tests/unit/test_zero_shot_classifier.py --cov=src/classification --cov-report=html

# Ejecutar tests de integraciÃ³n
poetry run pytest tests/integration/test_classification_workflow.py -v

# Ejecutar todos los tests de US-010
poetry run pytest tests/ -k "classification" -v
```

### MÃ©tricas de Ã‰xito

- [ ] Cobertura de cÃ³digo >70% (objetivo: 80%+)
- [ ] Todos los tests pasan (20+ unitarios, 3+ integraciÃ³n)
- [ ] Tiempo de ejecuciÃ³n <10s para tests unitarios
- [ ] Tiempo de ejecuciÃ³n <30s para tests de integraciÃ³n
- [ ] Sin warnings de pytest
- [ ] Sin errores de tipo (mypy)

---

## ğŸ“š Referencias AcadÃ©micas

### Zero-Shot Classification
1. **SAM-CLIP**: Wang, et al. (2024). "SAM-CLIP: Merging Vision Foundation Models towards Semantic and Spatial Understanding." *CVPR 2024 Workshop*.

2. **Hierarchical Transfer Learning**: Multiple 2024 papers on hierarchical classification for remote sensing (Level 1: coarse, Level 2: fine).

### Foundation Models
3. **Prithvi-EO-2.0**: Muhtar, D., et al. (2024). "Prithvi-EO-2.0: A Versatile Multi-Temporal Foundation Model for Earth Observation Applications." *arXiv:2412.02732*.

### Validation
4. **Dynamic World**: Brown, C.F., et al. (2022). "Dynamic World." *Scientific Data*, 9(1), 251.

---

## ğŸ“ˆ MÃ©tricas Esperadas y Benchmarks

### Resultados Esperados por Zona

**Basado en anÃ¡lisis preliminar de datos:**

| Zona | Regiones MGRG | Clases Esperadas | Agreement DW | Tiempo ClasificaciÃ³n |
|------|---------------|------------------|--------------|---------------------|
| **Mexicali** | 156 | Water (5%), Urban (8%), Bare Soil (15%), Crops (65%), Grass (7%) | 72-75% | <2s |
| **BajÃ­o** | 120 | Water (2%), Urban (12%), Bare Soil (10%), Crops (70%), Grass (6%) | 70-73% | <2s |
| **Sinaloa** | 180 | Water (8%), Urban (5%), Bare Soil (12%), Crops (68%), Grass (7%) | 71-74% | <2s |

### MÃ©tricas de Calidad por Clase

**Basado en literatura (Brown et al., 2022 - Dynamic World):**

| Clase | Agreement Esperado | Confianza Promedio | Notas |
|-------|-------------------|-------------------|-------|
| **Water** | 90-95% | 0.85-0.95 | Clase mÃ¡s fÃ¡cil (NDVI muy bajo) |
| **Urban** | 75-80% | 0.70-0.80 | ConfusiÃ³n con Bare Soil |
| **Bare Soil** | 65-70% | 0.60-0.75 | LÃ­mites ambiguos con Stressed Crop |
| **Vigorous Crop** | 75-80% | 0.80-0.90 | Alta confianza (NDVI >0.6) |
| **Stressed Crop** | 68-73% | 0.65-0.75 | Overlap con Bare Soil y Grass |
| **Grass/Shrub** | 60-65% | 0.60-0.70 | Clase mÃ¡s difÃ­cil (heterogÃ©nea) |

**Overall Agreement Target**: >70% (promedio ponderado)

### AnÃ¡lisis de Sensibilidad de Thresholds

**Thresholds NDVI a evaluar en notebook:**

| Threshold | Efecto Esperado | Uso Recomendado |
|-----------|----------------|-----------------|
| **water_urban: 0.05** | Muy restrictivo, menos Water | Zonas Ã¡ridas |
| **water_urban: 0.10** | EstÃ¡ndar (recomendado) | Uso general |
| **water_urban: 0.15** | Permisivo, mÃ¡s Water | Zonas hÃºmedas |
| **bare_soil: 0.25** | Menos Bare Soil, mÃ¡s Stressed Crop | Agricultura intensiva |
| **bare_soil: 0.30** | EstÃ¡ndar (recomendado) | Uso general |
| **bare_soil: 0.35** | MÃ¡s Bare Soil, menos Stressed Crop | Zonas secas |
| **stressed_crop: 0.55** | Menos Stressed, mÃ¡s Vigorous | Cultivos saludables |
| **stressed_crop: 0.60** | EstÃ¡ndar (recomendado) | Uso general |
| **stressed_crop: 0.65** | MÃ¡s Stressed, menos Vigorous | DetecciÃ³n temprana estrÃ©s |

**GrÃ¡fico a generar en notebook:**
```
Agreement vs Threshold
â”‚
â”‚  â—â”€â”€â”€â”€â—â”€â”€â”€â”€â—â”€â”€â”€â”€â—â”€â”€â”€â”€â—
â”‚                      â•²
â”‚                       â•²
â”‚                        â—â”€â”€â”€â”€â—
â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  0.05  0.10  0.15  0.20  0.25
       water_urban threshold
```

### ComparaciÃ³n con Estado del Arte

**Benchmarks de literatura:**

| MÃ©todo | Agreement | AÃ±o | Referencia |
|--------|-----------|-----|------------|
| **Dynamic World (Google)** | 86% | 2022 | Brown et al. |
| **SAM-CLIP** | 78% | 2024 | Wang et al. |
| **Prithvi-EO-2.0 (fine-tuned)** | 82% | 2024 | Muhtar et al. |
| **Nuestro mÃ©todo (zero-shot)** | **70-75%** (target) | 2025 | Este proyecto |

**InterpretaciÃ³n:**
- Nuestro mÃ©todo es zero-shot (sin entrenamiento)
- 70-75% es competitivo para zero-shot
- Fine-tuning podrÃ­a alcanzar 80%+ (trabajo futuro)

## âš ï¸ Riesgos y Mitigaciones

### Riesgo 1: Baja precisiÃ³n de clasificaciÃ³n (<65%)
**Probabilidad**: Media (30%)
**Impacto**: Alto (bloquea US)

**Mitigaciones**:
1. **Simplificar taxonomÃ­a**: Reducir a 4 clases (Water, Urban, Crop, Other)
2. **ClasificaciÃ³n binaria**: Crop vs Non-Crop como fallback
3. **Ajuste de thresholds**: CalibraciÃ³n por zona
4. **Uso de embeddings**: Agregar similitud coseno como feature adicional

**Plan B**: Si agreement <65%, usar clasificaciÃ³n jerÃ¡rquica:
- Nivel 1: Vegetation vs Non-Vegetation (NDVI >0.3)
- Nivel 2: Sub-clasificaciÃ³n dentro de cada grupo

### Riesgo 2: ConfusiÃ³n Urban â†” Bare Soil
**Probabilidad**: Alta (60%)
**Impacto**: Medio (afecta mÃ©tricas pero no bloquea)

**Mitigaciones**:
1. **Usar std de embeddings**: Urban tiene mayor variabilidad espacial
2. **AnÃ¡lisis de textura**: Calcular entropÃ­a local
3. **Contexto espacial**: Urban suele estar en clusters compactos
4. **Threshold adaptativo**: Ajustar por zona (urbano vs rural)

**ValidaciÃ³n**: InspecciÃ³n visual de casos ambiguos en notebook

### Riesgo 3: Threshold NDVI muy sensible
**Probabilidad**: Media (40%)
**Impacto**: Medio (requiere calibraciÃ³n manual)

**Mitigaciones**:
1. **AnÃ¡lisis de sensibilidad**: Evaluar thresholds 0.05-0.35 en notebook
2. **Thresholds adaptativos**: Calcular percentiles por zona
3. **Intervalos de confianza**: Usar rangos en lugar de valores fijos
4. **ValidaciÃ³n cruzada**: Comparar con Dynamic World para calibrar

**ImplementaciÃ³n**:
```python
# Threshold adaptativo basado en distribuciÃ³n local
def adaptive_threshold(ndvi, percentile=30):
    return np.percentile(ndvi[ndvi > 0], percentile)
```

### Riesgo 4: Dynamic World no disponible para todas las zonas
**Probabilidad**: Baja (20%)
**Impacto**: Medio (no se puede validar)

**Mitigaciones**:
1. **ValidaciÃ³n visual**: ComparaciÃ³n manual con RGB
2. **MÃ©tricas internas**: Coherencia, consistencia temporal
3. **Uso de otras fuentes**: ESA WorldCover, ESRI Land Cover
4. **ValidaciÃ³n cualitativa**: AnÃ¡lisis de casos de uso

### Riesgo 5: Tiempo de clasificaciÃ³n >5s
**Probabilidad**: Baja (15%)
**Impacto**: Bajo (no crÃ­tico para demo)

**Mitigaciones**:
1. **VectorizaciÃ³n NumPy**: Evitar loops Python
2. **Caching de estadÃ­sticas**: Pre-calcular mean/std por regiÃ³n
3. **ParalelizaciÃ³n**: Usar multiprocessing para mÃºltiples zonas
4. **OptimizaciÃ³n de cÃ³digo**: Profiling con cProfile

---

## ğŸ”® Hallazgos Esperados y Lecciones Anticipadas

### Hallazgos TÃ©cnicos Esperados

#### 1. Separabilidad de Clases por NDVI
**HipÃ³tesis**: Las clases se separan bien en el espacio NDVI

**ValidaciÃ³n esperada**:
- Water: NDVI <0.1 (separaciÃ³n clara)
- Urban/Bare Soil: NDVI 0.1-0.3 (overlap esperado)
- Crops: NDVI >0.3 (separaciÃ³n clara)

**MÃ©trica**: Calcular distancia entre distribuciones (Kolmogorov-Smirnov test)

#### 2. Rol de Embeddings SemÃ¡nticos
**HipÃ³tesis**: Embeddings ayudan a distinguir Urban vs Bare Soil

**ValidaciÃ³n esperada**:
- Calcular similitud coseno intra-clase vs inter-clase
- Urban deberÃ­a tener mayor variabilidad (std de embeddings)
- Bare Soil deberÃ­a ser mÃ¡s homogÃ©neo

**MÃ©trica**: Ratio de varianza intra-clase / inter-clase

#### 3. Consistencia Espacial
**HipÃ³tesis**: ClasificaciÃ³n mantiene coherencia espacial de MGRG

**ValidaciÃ³n esperada**:
- Regiones MGRG no se fragmentan en mÃºltiples clases
- Cada regiÃ³n tiene clase dominante >80%
- Transiciones suaves entre regiones vecinas

**MÃ©trica**: Pureza de regiÃ³n (% de pÃ­xeles de clase dominante)

#### 4. Sensibilidad a Thresholds
**HipÃ³tesis**: Thresholds NDVI son robustos Â±0.05

**ValidaciÃ³n esperada**:
- VariaciÃ³n de agreement <5% con threshold Â±0.05
- Clases extremas (Water, Vigorous Crop) mÃ¡s robustas
- Clases intermedias (Bare Soil, Stressed Crop) mÃ¡s sensibles

**MÃ©trica**: Curva de sensibilidad (agreement vs threshold)

### Lecciones Aprendidas Anticipadas

#### LecciÃ³n 1: Zero-Shot es Viable pero Limitado
**Expectativa**: 70-75% agreement es competitivo para zero-shot, pero lejos de mÃ©todos supervisados (85%+)

**ImplicaciÃ³n**: 
- Zero-shot es Ãºtil para prototipado rÃ¡pido
- Fine-tuning necesario para producciÃ³n
- Trade-off entre simplicidad y precisiÃ³n

#### LecciÃ³n 2: NDVI es Feature Dominante
**Expectativa**: NDVI explica >80% de la varianza en clasificaciÃ³n

**ImplicaciÃ³n**:
- Embeddings semÃ¡nticos son complementarios, no primarios
- ClasificaciÃ³n podrÃ­a simplificarse a solo NDVI + heurÃ­sticas
- Valor de embeddings estÃ¡ en casos ambiguos (Urban vs Bare Soil)

#### LecciÃ³n 3: JerarquÃ­a Clase â†’ EstrÃ©s es Correcta
**Expectativa**: AnÃ¡lisis jerÃ¡rquico mejora interpretabilidad

**ImplicaciÃ³n**:
- Primero identificar objeto (campo), luego analizar estrÃ©s interno
- Evita confundir "campo estresado" con "suelo desnudo"
- Alineado con workflow de agronomÃ­a real

#### LecciÃ³n 4: ValidaciÃ³n con Dynamic World es Imperfecta
**Expectativa**: Dynamic World tiene errores propios (10-15%)

**ImplicaciÃ³n**:
- Agreement 70-75% puede ser subestimado
- ValidaciÃ³n visual es necesaria
- MÃºltiples fuentes de ground truth son ideales

### Trabajo Futuro Identificado

#### Corto Plazo (US-011)
1. **IntegraciÃ³n en Pipeline End-to-End**
   - Endpoint REST: `/api/analysis/classify`
   - CLI script: `scripts/classify_region.py`
   - Procesamiento asÃ­ncrono con Celery

2. **ExportaciÃ³n de Resultados**
   - GeoTIFF con clases
   - Shapefile con polÃ­gonos por clase
   - JSON con estadÃ­sticas

#### Mediano Plazo (Post-Proyecto)
3. **Fine-Tuning de Prithvi**
   - Recolectar 100-200 ejemplos etiquetados
   - Fine-tune Ãºltima capa de Prithvi
   - Esperado: +10-15% agreement (80-85%)

4. **ClasificaciÃ³n Temporal**
   - Usar series temporales de NDVI (3-6 meses)
   - Detectar patrones estacionales (siembra, cosecha)
   - Mejorar separaciÃ³n Crop vs Grass/Shrub

5. **ClasificaciÃ³n Multi-Escala**
   - Nivel 1: Coarse (6 clases)
   - Nivel 2: Fine (15 clases: tipos de cultivos)
   - Nivel 3: EstrÃ©s (bajo/medio/alto)

#### Largo Plazo (InvestigaciÃ³n)
6. **Active Learning**
   - Identificar regiones con baja confianza
   - Solicitar etiquetas de usuario selectivamente
   - Refinamiento iterativo del clasificador

7. **Transferencia a Otras Regiones**
   - Evaluar en Europa, Ãfrica, Asia
   - CalibraciÃ³n automÃ¡tica de thresholds
   - AdaptaciÃ³n a diferentes climas

8. **IntegraciÃ³n con Modelos de Cultivo**
   - Combinar clasificaciÃ³n con modelos agronÃ³micos (DSSAT, APSIM)
   - PredicciÃ³n de rendimiento por clase
   - Recomendaciones de manejo

---

## ğŸ“Š MÃ©tricas de Ã‰xito de la US

### Criterios MÃ­nimos (Must Have)
- [ ] Clasificador implementado y funcional
- [ ] Tests >70% cobertura, todos pasan
- [ ] Notebook demostrativo completo
- [ ] Agreement con Dynamic World >65%
- [ ] DocumentaciÃ³n completa (README + resoluciÃ³n)

### Criterios Deseables (Should Have)
- [ ] Agreement con Dynamic World >70%
- [ ] Tests >80% cobertura
- [ ] AnÃ¡lisis de sensibilidad de thresholds
- [ ] Visualizaciones de calidad para paper (300 DPI)
- [ ] ComparaciÃ³n con 3 zonas

### Criterios Opcionales (Nice to Have)
- [ ] Agreement con Dynamic World >75%
- [ ] ClasificaciÃ³n temporal (mÃºltiples fechas)
- [ ] ExportaciÃ³n a GeoTIFF/Shapefile
- [ ] Dashboard interactivo (Streamlit)

---

## âœ… DefiniciÃ³n de Completado (DoD)

### CÃ³digo
- [ ] `src/classification/zero_shot_classifier.py` implementado (700+ lÃ­neas)
- [ ] Clase `SemanticClassifier` completa con 9 mÃ©todos
- [ ] FunciÃ³n `cross_validate_with_dynamic_world()` implementada
- [ ] Type hints en todas las funciones
- [ ] Docstrings estilo Google en todas las funciones pÃºblicas
- [ ] Logging profesional (logger, no print)
- [ ] Sin emojis en cÃ³digo Python

### Testing
- [ ] Tests unitarios: 20+ tests, >70% cobertura (objetivo: 80%+)
- [ ] Tests de integraciÃ³n: 3+ tests
- [ ] Todos los tests pasan (0 failed)
- [ ] Tiempo de ejecuciÃ³n <10s (unitarios), <30s (integraciÃ³n)
- [ ] Sin warnings de pytest
- [ ] Sin errores de tipo (mypy)

### Notebook
- [ ] `notebooks/classification/semantic_classification.ipynb` creado
- [ ] AplicaciÃ³n a 3 zonas (Mexicali, BajÃ­o, Sinaloa)
- [ ] Visualizaciones profesionales (300 DPI)
- [ ] EstadÃ­sticas por clase (tabla + grÃ¡ficos)
- [ ] Cross-validation con Dynamic World
- [ ] AnÃ¡lisis jerÃ¡rquico (Clase â†’ EstrÃ©s)
- [ ] Texto explicativo en espaÃ±ol
- [ ] CÃ³digo en inglÃ©s
- [ ] Sin emojis en cÃ³digo Python
- [ ] Resultados reproducibles

### DocumentaciÃ³n
- [ ] README.md actualizado con secciÃ³n US-010 (80-100 lÃ­neas)
- [ ] `docs/us-resolved/us-010.md` creado siguiendo template US-008/009
- [ ] Ejemplos de uso con cÃ³digo ejecutable
- [ ] Tabla de mÃ©tricas tÃ­picas
- [ ] Referencias acadÃ©micas (4+ papers)
- [ ] Lecciones aprendidas documentadas
- [ ] Trabajo futuro identificado

### Calidad
- [ ] CÃ³digo siguiendo AGENTS.md (sin emojis en Python)
- [ ] Funciones reutilizables en `src/classification/`
- [ ] Helpers para notebooks en `src/utils/` (opcional)
- [ ] Logs silenciables para presentaciÃ³n limpia
- [ ] DataFrames de pandas para output limpio
- [ ] Confusion matrices guardadas en disco
- [ ] ExportaciÃ³n de resultados (CSV, PNG, JSON)

---

## ğŸ¯ Comandos de EjecuciÃ³n RÃ¡pida

### Desarrollo

```bash
# Ejecutar tests unitarios
poetry run pytest tests/unit/test_zero_shot_classifier.py -v

# Ejecutar tests con cobertura
poetry run pytest tests/unit/test_zero_shot_classifier.py --cov=src/classification --cov-report=html

# Ejecutar tests de integraciÃ³n
poetry run pytest tests/integration/test_classification_workflow.py -v

# Ejecutar todos los tests de US-010
poetry run pytest tests/ -k "classification" -v
```

### Notebook

```bash
# Abrir notebook demostrativo
jupyter notebook notebooks/classification/semantic_classification.ipynb
```

### ValidaciÃ³n

```bash
# Verificar cobertura de tests
poetry run pytest tests/unit/test_zero_shot_classifier.py --cov=src/classification --cov-report=term-missing

# Verificar type hints
poetry run mypy src/classification/zero_shot_classifier.py

# Verificar estilo de cÃ³digo
poetry run black src/classification/zero_shot_classifier.py --check
poetry run ruff check src/classification/zero_shot_classifier.py
```

---

## ğŸ“ Soporte y Contacto

### Archivos Clave

**CÃ³digo Principal:**
- `src/classification/zero_shot_classifier.py` - MÃ³dulo de clasificaciÃ³n
- `src/utils/validation_helpers.py` - Helpers para notebooks (opcional)

**Tests:**
- `tests/unit/test_zero_shot_classifier.py` - Tests unitarios
- `tests/integration/test_classification_workflow.py` - Tests de integraciÃ³n

**Notebooks:**
- `notebooks/classification/semantic_classification.ipynb` - Demo completo

**DocumentaciÃ³n:**
- `docs/us-planning/us-010.md` - Este documento (planeaciÃ³n)
- `docs/us-resolved/us-010.md` - ResoluciÃ³n completa (crear al finalizar)
- `README.md` - DocumentaciÃ³n principal del proyecto

### Estructura de Datos Esperada

```
data/
â”œâ”€â”€ embeddings/
â”‚   â”œâ”€â”€ mexicali_embeddings.npy  # (H, W, 256)
â”‚   â”œâ”€â”€ bajio_embeddings.npy
â”‚   â””â”€â”€ sinaloa_embeddings.npy
â”œâ”€â”€ ndvi/
â”‚   â”œâ”€â”€ mexicali_ndvi.npy  # (H, W)
â”‚   â”œâ”€â”€ bajio_ndvi.npy
â”‚   â””â”€â”€ sinaloa_ndvi.npy
â”œâ”€â”€ segmentation/
â”‚   â”œâ”€â”€ mexicali_mgrg.npy  # (H, W) con IDs de regiÃ³n
â”‚   â”œâ”€â”€ bajio_mgrg.npy
â”‚   â””â”€â”€ sinaloa_mgrg.npy
â”œâ”€â”€ dynamic_world/
â”‚   â”œâ”€â”€ mexicali_dw.npy  # (H, W) con clases DW
â”‚   â”œâ”€â”€ bajio_dw.npy
â”‚   â””â”€â”€ sinaloa_dw.npy
â””â”€â”€ rgb/
    â”œâ”€â”€ mexicali_rgb.npy  # (H, W, 3) para visualizaciÃ³n
    â”œâ”€â”€ bajio_rgb.npy
    â””â”€â”€ sinaloa_rgb.npy
```

### Resultados Esperados

```
img/results/classification/
â”œâ”€â”€ semantic_map_mexicali.png  # Mapa semÃ¡ntico coloreado
â”œâ”€â”€ semantic_map_bajio.png
â”œâ”€â”€ semantic_map_sinaloa.png
â”œâ”€â”€ class_statistics_mexicali.csv  # EstadÃ­sticas por clase
â”œâ”€â”€ class_statistics_bajio.csv
â”œâ”€â”€ class_statistics_sinaloa.csv
â”œâ”€â”€ confusion_matrix_mexicali.png  # Confusion matrix vs DW
â”œâ”€â”€ confusion_matrix_bajio.png
â”œâ”€â”€ confusion_matrix_sinaloa.png
â”œâ”€â”€ comparison_rgb_mgrg_semantic.png  # Comparativa 3 paneles
â””â”€â”€ classification_results.json  # Resultados agregados
```

---

## ğŸ“ Aprendizajes de US-008 y US-009 Aplicados

### De US-008 (ComparaciÃ³n A/B)

1. **Backend no-interactivo**: Usar `matplotlib.use('Agg')` para evitar problemas con Tkinter
2. **Compatibilidad matplotlib**: Usar `buffer_rgba()` en lugar de `tostring_rgb()` (deprecado)
3. **ExportaciÃ³n multi-formato**: PNG, PDF, SVG con DPI configurable
4. **Tests exhaustivos**: 52 tests (25 unitarios mÃ©tricas + 18 unitarios visualizaciÃ³n + 9 integraciÃ³n)
5. **Cobertura alta**: 95% total (87% mÃ©tricas, 99% visualizaciÃ³n)

### De US-009 (ValidaciÃ³n Cuantitativa)

1. **Helpers para notebooks**: Crear `src/utils/classification_helpers.py` con funciones reutilizables
2. **Output limpio**: Usar DataFrames de pandas en lugar de prints
3. **Logs silenciables**: `logger.setLevel(logging.WARNING)` para presentaciÃ³n
4. **MÃ©tricas agregadas**: Calcular promedio y desviaciÃ³n estÃ¡ndar entre zonas
5. **Confusion matrices**: Mostrar en notebook Y guardar en disco
6. **DocumentaciÃ³n consolidada**: Un solo archivo en `us-resolved/` (no mÃºltiples)
7. **Iteraciones documentadas**: Historia de desarrollo en resoluciÃ³n final
8. **Fallback robusto**: PriorizaciÃ³n automÃ¡tica de fuentes de datos

### Mejoras EspecÃ­ficas para US-010

1. **Crear `src/utils/classification_helpers.py`** (opcional pero recomendado):
   ```python
   def load_classification_data(zone_name: str) -> Dict:
       """Load embeddings, NDVI, segmentation for a zone"""
       
   def classify_zone(zone_name: str, classifier: SemanticClassifier) -> Dict:
       """Classify all regions in a zone and return results"""
       
   def display_classification_results(results: Dict, zone_name: str):
       """Display results in clean DataFrame format"""
       
   def create_classification_summary(zones: List[str]) -> pd.DataFrame:
       """Create summary table across all zones"""
   ```

2. **Estructura de notebook mejorada**:
   - Usar funciones de helpers para cargar datos
   - Silenciar logs molestos
   - Mostrar resultados en DataFrames
   - Guardar figuras automÃ¡ticamente
   - Exportar resultados en mÃºltiples formatos

3. **DocumentaciÃ³n final**:
   - Un solo archivo `us-resolved/us-010.md`
   - Incluir historia de iteraciones
   - Documentar hallazgos experimentales
   - Lecciones aprendidas detalladas
   - Impacto del trabajo (tÃ©cnico, cientÃ­fico, prÃ¡ctico)

---

## ğŸš€ PrÃ³ximos Pasos Inmediatos

### Fase 1: ImplementaciÃ³n (3 horas)
1. Crear `src/classification/zero_shot_classifier.py` con clase `SemanticClassifier`
2. Implementar 9 mÃ©todos principales
3. Implementar funciÃ³n `cross_validate_with_dynamic_world()`
4. Agregar logging profesional

### Fase 2: Testing (2 horas)
1. Crear `tests/unit/test_zero_shot_classifier.py` con 20+ tests
2. Crear `tests/integration/test_classification_workflow.py` con 3+ tests
3. Verificar cobertura >70%
4. Ejecutar todos los tests

### Fase 3: Notebook (2 horas)
1. Crear `notebooks/classification/semantic_classification.ipynb`
2. Implementar 8 secciones principales
3. Aplicar a 3 zonas (Mexicali, BajÃ­o, Sinaloa)
4. Generar visualizaciones profesionales (300 DPI)

### Fase 4: DocumentaciÃ³n (1 hora)
1. Actualizar `README.md` con secciÃ³n US-010
2. Crear `docs/us-resolved/us-010.md` siguiendo template US-008/009
3. Exportar resultados (CSV, PNG, JSON)
4. Verificar cumplimiento de AGENTS.md

---

**Autor:** Arthur Zizumbo  
**Fecha de PlaneaciÃ³n:** 11 de Noviembre de 2025  
**EstimaciÃ³n Total:** 8 horas  
**Prioridad:** ALTA  
**Estado:** ğŸ“‹ PLANEACIÃ“N COMPLETA  
**Siguiente Paso:** ImplementaciÃ³n de `SemanticClassifier`

---

**VersiÃ³n:** 2.0 (Mejorada con aprendizajes de US-008 y US-009)  
**Ãšltima ActualizaciÃ³n:** 12 de Noviembre de 2025mic World tiene errores propios (10-15%)

**ImplicaciÃ³n**:
- Agreement 70-75% puede ser subestimado
- ValidaciÃ³n visual es necesaria
- MÃºltiples fuentes de ground truth son ideales

### Trabajo Futuro Identificado

#### Corto Plazo (US-011)
1. **IntegraciÃ³n en Pipeline End-to-End**
   - Endpoint REST: `/api/analysis/classify`
   - CLI script: `scripts/classify_region.py`
   - Procesamiento asÃ­ncrono con Celery

2. **ExportaciÃ³n de Resultados**
   - GeoTIFF con clases
   - Shapefile con polÃ­gonos por clase
   - JSON con estadÃ­sticas

#### Mediano Plazo (Post-Proyecto)
3. **Fine-Tuning de Prithvi**
   - Recolectar 100-200 ejemplos etiquetados
   - Fine-tune Ãºltima capa de Prithvi
   - Esperado: +10-15% agreement (80-85%)

4. **ClasificaciÃ³n Temporal**
   - Usar series temporales de NDVI (3-6 meses)
   - Detectar patrones estacionales (siembra, cosecha)
   - Mejorar separaciÃ³n Crop vs Grass/Shrub

5. **ClasificaciÃ³n Multi-Escala**
   - Nivel 1: Coarse (6 clases)
   - Nivel 2: Fine (15 clases: tipos de cultivos)
   - Nivel 3: EstrÃ©s (bajo/medio/alto)

#### Largo Plazo (InvestigaciÃ³n)
6. **Active Learning**
   - Identificar regiones con baja confianza
   - Solicitar etiquetas de usuario selectivamente
   - Refinamiento iterativo del clasificador

7. **Transferencia a Otras Regiones**
   - Evaluar en Europa, Ãfrica, Asia
   - CalibraciÃ³n automÃ¡tica de thresholds
   - AdaptaciÃ³n a diferentes climas

8. **IntegraciÃ³n con Modelos de Cultivo**
   - Combinar clasificaciÃ³n con modelos agronÃ³micos (DSSAT, APSIM)
   - PredicciÃ³n de rendimiento por clase
   - Recomendaciones de manejo

## ğŸ“Š MÃ©tricas de Ã‰xito de la US

### Criterios MÃ­nimos (Must Have)
- [ ] Clasificador implementado y funcional
- [ ] Tests >70% cobertura, todos pasan
- [ ] Notebook demostrativo completo
- [ ] Agreement con Dynamic World >65%
- [ ] DocumentaciÃ³n completa (README + resoluciÃ³n)

### Criterios Deseables (Should Have)
- [ ] Agreement con Dynamic World >70%
- [ ] Tests >80% cobertura
- [ ] AnÃ¡lisis de sensibilidad de thresholds
- [ ] Visualizaciones de calidad para paper (300 DPI)
- [ ] ComparaciÃ³n con 3 zonas

### Criterios Opcionales (Nice to Have)
- [ ] Agreement con Dynamic World >75%
- [ ] ClasificaciÃ³n temporal (mÃºltiples fechas)
- [ ] ExportaciÃ³n a GeoTIFF/Shapefile
- [ ] Dashboard interactivo (Streamlit)

## âœ… DefiniciÃ³n de Completado (DoD)

### CÃ³digo
- [ ] `src/classification/zero_shot_classifier.py` implementado (700+ lÃ­neas)
- [ ] Clase `SemanticClassifier` completa con 9 mÃ©todos
- [ ] FunciÃ³n `cross_validate_with_dynamic_world()` implementada
- [ ] Type hints en todas las funciones
- [ ] Docstrings estilo Google en todas las funciones pÃºblicas
- [ ] Logging profesional (logger, no print)
- [ ] Sin emojis en cÃ³digo Python

### Testing
- [ ] Tests unitarios: 20+ tests, >70% cobertura (objetivo: 80%+)
- [ ] Tests de integraciÃ³n: 3+ tests
- [ ] Todos los tests pasan (0 failed)
- [ ] Tiempo de ejecuciÃ³n <10s (unitarios), <30s (integraciÃ³n)
- [ ] Sin warnings de pytest
- [ ] Sin errores de tipo (mypy)

### Notebook
- [ ] `notebooks/classification/semantic_classification.ipynb` creado
- [ ] AplicaciÃ³n a 3 zonas (Mexicali, BajÃ­o, Sinaloa)
- [ ] Visualizaciones profesionales (300 DPI)
- [ ] EstadÃ­sticas por clase (tabla + grÃ¡ficos)
- [ ] Cross-validation con Dynamic World
- [ ] AnÃ¡lisis de sensibilidad de thresholds
- [ ] Conclusiones y recomendaciones
- [ ] Texto en espaÃ±ol, cÃ³digo en inglÃ©s

### DocumentaciÃ³n
- [ ] README actualizado con secciÃ³n US-010 (80-100 lÃ­neas)
- [ ] Ejemplos de uso con cÃ³digo ejecutable
- [ ] Tabla de mÃ©tricas tÃ­picas
- [ ] Referencias acadÃ©micas (3+ papers)
- [ ] `docs/us-resolved/us-010.md` creado (siguiendo template US-007/008)
- [ ] Resumen ejecutivo con resultados cuantitativos
- [ ] Hallazgos clave y lecciones aprendidas
- [ ] Trabajo futuro identificado

### Calidad
- [ ] CÃ³digo siguiendo AGENTS.md (100% compliance)
- [ ] PEP 8 compliant (verificado con ruff)
- [ ] Sin errores de diagnÃ³stico (getDiagnostics)
- [ ] Cobertura de tests >70% (verificado con pytest-cov)
- [ ] DocumentaciÃ³n completa y profesional

### Resultados
- [ ] Agreement con Dynamic World >70% (promedio de 3 zonas)
- [ ] Mapa semÃ¡ntico generado para 3 zonas
- [ ] Tabla de estadÃ­sticas por clase
- [ ] Visualizaciones de calidad para paper (PNG 300 DPI)
- [ ] AnÃ¡lisis cuantitativo de resultados

## ğŸ“ Checklist de Entrega

### Pre-Desarrollo
- [ ] Leer y entender US-007 y US-008 (estÃ¡ndar de excelencia)
- [ ] Revisar papers de referencia (Prithvi, Dynamic World)
- [ ] Configurar entorno de desarrollo
- [ ] Crear rama `us-010` desde `main`

### Desarrollo
- [ ] Implementar `SemanticClassifier` (Fase 1)
- [ ] Implementar tests unitarios (Fase 2)
- [ ] Crear notebook demostrativo (Fase 3)
- [ ] Ejecutar anÃ¡lisis en 3 zonas
- [ ] Generar visualizaciones

### Testing y ValidaciÃ³n
- [ ] Ejecutar todos los tests (unitarios + integraciÃ³n)
- [ ] Verificar cobertura >70%
- [ ] Validar con Dynamic World
- [ ] InspecciÃ³n visual de resultados
- [ ] AnÃ¡lisis de casos ambiguos

### DocumentaciÃ³n
- [ ] Actualizar README con secciÃ³n US-010
- [ ] Crear `docs/us-resolved/us-010.md`
- [ ] Documentar hallazgos y lecciones aprendidas
- [ ] Agregar referencias acadÃ©micas
- [ ] Revisar ortografÃ­a y formato

### RevisiÃ³n Final
- [ ] Code review (verificar AGENTS.md compliance)
- [ ] Ejecutar linter (ruff)
- [ ] Ejecutar type checker (mypy)
- [ ] Verificar que todos los tests pasan
- [ ] Merge a `main` con PR descriptivo

---

## ğŸ“ Contacto y Soporte

**Desarrollador Asignado**: Arthur Zizumbo
**Fecha LÃ­mite**: 12 de Noviembre de 2025
**EstimaciÃ³n**: 8 horas
**Prioridad**: ALTA

**Recursos**:
- PlaneaciÃ³n: `docs/us-planning/us-010.md` (este archivo)
- EstÃ¡ndar: `AGENTS.md`
- Referencias: US-007, US-008 (ejemplos de excelencia)
- Papers: Ver secciÃ³n "Referencias AcadÃ©micas"

**Preguntas Frecuentes**:
1. **Â¿QuÃ© hacer si agreement <70%?** â†’ Ver secciÃ³n "Riesgos y Mitigaciones"
2. **Â¿CÃ³mo calibrar thresholds?** â†’ AnÃ¡lisis de sensibilidad en notebook
3. **Â¿QuÃ© hacer si Dynamic World no estÃ¡ disponible?** â†’ ValidaciÃ³n visual + mÃ©tricas internas
4. **Â¿CÃ³mo manejar casos ambiguos?** â†’ Documentar en notebook, usar confianza baja

---

**Autor**: Arthur Zizumbo (con asistencia de Claude)
**Fecha de CreaciÃ³n**: 11 de Noviembre de 2025
**Ãšltima ActualizaciÃ³n**: 11 de Noviembre de 2025
**VersiÃ³n**: 2.0 (Mejorada con estÃ¡ndar US-007/008)
