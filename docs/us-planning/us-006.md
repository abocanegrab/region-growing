# US-006: Extraer Embeddings de Im√°genes Sentinel-2

**Epic:** Innovaci√≥n SOTA (D√≠as 4-7)  
**Prioridad:** Alta (Bloqueante para US-007)  
**Estimaci√≥n:** 12 horas (10h original + 2h API)  
**Responsables:** Arthur Zizumbo + Luis V√°zquez  
**Estado:** üìã PLANIFICACI√ìN  
**Fecha de Planificaci√≥n:** 9 de Noviembre de 2025  
**Versi√≥n:** 1.1.0 (Actualizada con zonas de M√©xico y API)

---

## üìã Historia de Usuario

**Como** desarrollador  
**Quiero** extraer embeddings sem√°nticos de im√°genes Sentinel-2 usando Prithvi  
**Para que** podamos usar el m√©todo MGRG (Metric-Guided Region Growing) con caracter√≠sticas sem√°nticas robustas

---

## üéØ Objetivos

### Objetivo Principal
Implementar un pipeline completo para extraer embeddings sem√°nticos de 256 dimensiones desde im√°genes Sentinel-2, preparando las bandas HLS correctas y usando el modelo Prithvi pre-entrenado.

### Objetivos Espec√≠ficos

1. **Descarga de Bandas HLS Correctas**
   - Implementar descarga de las 6 bandas espec√≠ficas de Prithvi
   - Descargar im√°genes de **zonas agr√≠colas de M√©xico** (Valle de Mexicali, Baj√≠o, etc.)
   - Manejar bandas de diferentes resoluciones (10m y 20m)
   - Validar orden exacto de bandas

2. **Remuestreo de Bandas 20m ‚Üí 10m**
   - Implementar interpolaci√≥n bilinear para B8A, B11, B12
   - Validar calidad del remuestreo
   - Optimizar performance

3. **Preparaci√≥n de Imagen HLS**
   - Apilar bandas en orden correcto
   - Normalizar imagen (mean=0, std=1)
   - Validar formato de entrada para Prithvi

4. **Extracci√≥n de Embeddings**
   - Usar modelo Prithvi (encoder only)
   - Obtener embeddings de 256 dimensiones
   - Normalizar embeddings (L2 norm) para cosine similarity

5. **Validaci√≥n y Testing**
   - Tests unitarios completos
   - Validaci√≥n visual de embeddings
   - Notebook de demostraci√≥n

6. **Integraci√≥n con API FastAPI**
   - Crear endpoints para extracci√≥n de embeddings
   - Integrar con endpoints existentes de an√°lisis
   - Documentaci√≥n OpenAPI/Swagger

---

## ‚ö†Ô∏è CR√çTICO - Bandas Correctas para Prithvi

### Bandas Requeridas (Orden Exacto)

Prithvi-EO-1.0-100M fue pre-entrenado en formato HLS y requiere **exactamente 6 bandas en orden espec√≠fico**:

| # | Banda | Nombre | Longitud de Onda | Resoluci√≥n Original | Resoluci√≥n Final |
|---|-------|--------|------------------|---------------------|------------------|
| 1 | B02 | Blue | 490 nm | 10m | 10m |
| 2 | B03 | Green | 560 nm | 10m | 10m |
| 3 | B04 | Red | 665 nm | 10m | 10m |
| 4 | **B8A** | NIR Narrow | 865 nm | **20m** | 10m (resample) |
| 5 | B11 | SWIR1 | 1610 nm | **20m** | 10m (resample) |
| 6 | B12 | SWIR2 | 2190 nm | **20m** | 10m (resample) |

### ‚ö†Ô∏è Diferencia Cr√≠tica: B08 vs B8A

**NO USAR B08** - Prithvi espera **B8A**:

| Banda | Nombre | Resoluci√≥n | Ancho de Banda | Uso en Prithvi |
|-------|--------|------------|----------------|----------------|
| B08 | NIR Broad | 10m | 115 nm | ‚ùå NO |
| B8A | NIR Narrow | 20m | 20 nm | ‚úÖ S√ç |

**Raz√≥n:** Prithvi fue entrenado con datos HLS que usan B8A (NIR Narrow) de Sentinel-2, no B08.

### Conflicto con config.yaml

El archivo `models/prithvi/config.yaml` menciona bandas diferentes (B02, B03, B04, B05, B06, B07), pero esto es **incorrecto** para nuestro caso de uso. Seg√∫n la documentaci√≥n oficial de HuggingFace y el paper de Prithvi, el modelo espera las 6 bandas HLS est√°ndar.

**Decisi√≥n:** Seguir la especificaci√≥n de HuggingFace (B02, B03, B04, B8A, B11, B12) que es la correcta para Sentinel-2 ‚Üí HLS.

---

## üá≤üáΩ Zonas de Estudio en M√©xico

### √Åreas Seleccionadas

Para validar el sistema con datos reales, se descargar√°n im√°genes de **3 zonas agr√≠colas representativas de M√©xico**:

#### 1. Valle de Mexicali, Baja California
**Coordenadas:** 32.5¬∞N, -115.3¬∞W  
**Caracter√≠sticas:**
- Agricultura intensiva de riego
- Cultivos principales: Trigo, algod√≥n, alfalfa
- Clima des√©rtico con riego del R√≠o Colorado
- Ideal para detectar estr√©s h√≠drico

**BBox Sugerido:**
```python
bbox_mexicali = {
    'min_lat': 32.45,
    'min_lon': -115.35,
    'max_lat': 32.55,
    'max_lon': -115.25
}
```

#### 2. Baj√≠o (Guanajuato)
**Coordenadas:** 20.9¬∞N, -101.4¬∞W  
**Caracter√≠sticas:**
- Zona agr√≠cola m√°s productiva de M√©xico
- Cultivos diversos: Ma√≠z, sorgo, trigo, hortalizas
- Agricultura de temporal y riego
- Variabilidad de estr√©s por tipo de cultivo

**BBox Sugerido:**
```python
bbox_bajio = {
    'min_lat': 20.85,
    'min_lon': -101.45,
    'max_lat': 20.95,
    'max_lon': -101.35
}
```

#### 3. Valle de Culiac√°n, Sinaloa
**Coordenadas:** 24.8¬∞N, -107.4¬∞W  
**Caracter√≠sticas:**
- Agricultura de exportaci√≥n (hortalizas)
- Cultivos: Tomate, chile, pepino
- Riego tecnificado
- Excelente para validar detecci√≥n de estr√©s

**BBox Sugerido:**
```python
bbox_sinaloa = {
    'min_lat': 24.75,
    'min_lon': -107.45,
    'max_lat': 24.85,
    'max_lon': -107.35
}
```

### Justificaci√≥n de Selecci√≥n

Estas zonas fueron seleccionadas porque:
- ‚úÖ **Diversidad agr√≠cola:** Diferentes tipos de cultivos y sistemas de riego
- ‚úÖ **Relevancia econ√≥mica:** Zonas de alta producci√≥n agr√≠cola
- ‚úÖ **Variabilidad de estr√©s:** Permiten validar diferentes niveles de estr√©s vegetal
- ‚úÖ **Disponibilidad de datos:** Cobertura regular de Sentinel-2
- ‚úÖ **Clima variado:** Des√©rtico, templado y tropical

---

## üèóÔ∏è Arquitectura de la Soluci√≥n

### Componentes a Implementar

```
src/features/
‚îî‚îÄ‚îÄ hls_processor.py          # Nuevo m√≥dulo para procesamiento HLS

src/utils/
‚îî‚îÄ‚îÄ sentinel_download.py      # Modificar para soportar bandas HLS

backend/app/api/routes/
‚îî‚îÄ‚îÄ embeddings.py             # Nuevo: Endpoints para embeddings

backend/app/services/
‚îî‚îÄ‚îÄ embeddings_service.py     # Nuevo: Servicio de embeddings

backend/app/api/schemas/
‚îú‚îÄ‚îÄ requests.py               # Actualizar: EmbeddingsRequest
‚îî‚îÄ‚îÄ responses.py              # Actualizar: EmbeddingsResponse

scripts/
‚îú‚îÄ‚îÄ download_hls_image.py     # Script para descargar imagen HLS
‚îî‚îÄ‚îÄ test_embeddings.py        # Script para probar extracci√≥n

tests/unit/
‚îú‚îÄ‚îÄ test_hls_processor.py     # Tests unitarios (20+ tests)
‚îî‚îÄ‚îÄ test_embeddings_api.py    # Tests de endpoints API

notebooks/experimental/
‚îî‚îÄ‚îÄ us-006-embeddings-demo.ipynb  # Notebook de demostraci√≥n

img/
‚îî‚îÄ‚îÄ sentinel2/                # Directorio para im√°genes descargadas
    ‚îú‚îÄ‚îÄ mexico/               # Im√°genes de M√©xico
    ‚îÇ   ‚îú‚îÄ‚îÄ mexicali/         # Valle de Mexicali (agricultura intensiva)
    ‚îÇ   ‚îú‚îÄ‚îÄ bajio/            # Baj√≠o (cultivos diversos)
    ‚îÇ   ‚îî‚îÄ‚îÄ sinaloa/          # Sinaloa (agricultura de riego)
    ‚îú‚îÄ‚îÄ hls_bands/            # Bandas HLS individuales
    ‚îî‚îÄ‚îÄ embeddings/           # Embeddings extra√≠dos
```

### Pipeline de Procesamiento

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    1. DESCARGA DE BANDAS                         ‚îÇ
‚îÇ  Sentinel Hub API ‚Üí 6 bandas (B02,B03,B04,B8A,B11,B12)         ‚îÇ
‚îÇ  Resoluciones: 10m (3 bandas) + 20m (3 bandas)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    2. REMUESTREO 20m ‚Üí 10m                       ‚îÇ
‚îÇ  scipy.ndimage.zoom() con interpolaci√≥n bilinear (order=1)      ‚îÇ
‚îÇ  B8A: 20m ‚Üí 10m                                                 ‚îÇ
‚îÇ  B11: 20m ‚Üí 10m                                                 ‚îÇ
‚îÇ  B12: 20m ‚Üí 10m                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    3. APILADO Y NORMALIZACI√ìN                    ‚îÇ
‚îÇ  np.stack([B02, B03, B04, B8A, B11, B12], axis=0)              ‚îÇ
‚îÇ  Normalizaci√≥n: (x - mean) / std                                ‚îÇ
‚îÇ  Shape: (6, H, W) ‚Üí (1, 6, H, W) para PyTorch                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    4. INFERENCIA CON PRITHVI                     ‚îÇ
‚îÇ  load_prithvi_model(use_simple_model=False)                     ‚îÇ
‚îÇ  embeddings = encoder(hls_tensor)                               ‚îÇ
‚îÇ  Output: (1, 256, H', W')                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
                             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    5. POST-PROCESAMIENTO                         ‚îÇ
‚îÇ  Interpolar a resoluci√≥n original si es necesario               ‚îÇ
‚îÇ  Normalizar embeddings (L2 norm) para cosine similarity         ‚îÇ
‚îÇ  Output final: (H, W, 256) numpy array                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìù Criterios de Aceptaci√≥n Detallados

### 1. Descarga de Bandas HLS ‚úÖ

**Criterio:** Sistema descarga las 6 bandas correctas de Sentinel-2

**Implementaci√≥n:**
- Modificar `src/utils/sentinel_download.py` para soportar bandas HLS
- Crear funci√≥n `download_hls_bands()` espec√≠fica
- Manejar bandas de diferentes resoluciones
- Validar que se descarguen las bandas correctas

**Tests:**
- Test de descarga exitosa
- Test de validaci√≥n de bandas
- Test de manejo de errores (√°rea sin datos, etc.)

**C√≥digo Esperado:**
```python
def download_hls_bands(
    bbox_coords: Dict[str, float],
    config: SHConfig,
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    max_cloud_coverage: float = 0.3
) -> Dict:
    """
    Download HLS bands for Prithvi model.
    
    Downloads 6 bands in correct order:
    B02, B03, B04 (10m) + B8A, B11, B12 (20m)
    """
    bands_10m = ['B02', 'B03', 'B04']
    bands_20m = ['B8A', 'B11', 'B12']
    
    # Download with evalscript
    evalscript = """
    //VERSION=3
    function setup() {
        return {
            input: [{
                bands: ["B02", "B03", "B04", "B8A", "B11", "B12"],
                units: "REFLECTANCE"
            }],
            output: { bands: 6, sampleType: "FLOAT32" }
        };
    }
    function evaluatePixel(sample) {
        return [sample.B02, sample.B03, sample.B04, 
                sample.B8A, sample.B11, sample.B12];
    }
    """
    # ... rest of implementation
```

### 2. Remuestreo de Bandas 20m ‚Üí 10m ‚úÖ

**Criterio:** Bandas B8A, B11, B12 remuestreadas correctamente a 10m

**Implementaci√≥n:**
- Crear funci√≥n `resample_band_to_10m()` en `src/features/hls_processor.py`
- Usar `scipy.ndimage.zoom()` con interpolaci√≥n bilinear (order=1)
- Validar dimensiones de salida
- Optimizar para m√∫ltiples bandas

**Tests:**
- Test de remuestreo correcto (dimensiones)
- Test de calidad de interpolaci√≥n
- Test de preservaci√≥n de valores
- Test de performance

**C√≥digo Esperado:**
```python
from scipy.ndimage import zoom

def resample_band_to_10m(
    band_20m: np.ndarray,
    target_shape: Optional[Tuple[int, int]] = None
) -> np.ndarray:
    """
    Resample 20m band to 10m resolution using bilinear interpolation.
    
    Parameters
    ----------
    band_20m : np.ndarray
        Band at 20m resolution (H/2, W/2)
    target_shape : tuple, optional
        Target shape (H, W). If None, doubles dimensions.
        
    Returns
    -------
    np.ndarray
        Resampled band at 10m resolution (H, W)
    """
    if target_shape is not None:
        zoom_factors = (
            target_shape[0] / band_20m.shape[0],
            target_shape[1] / band_20m.shape[1]
        )
    else:
        zoom_factors = (2, 2)
    
    return zoom(band_20m, zoom_factors, order=1)  # Bilinear
```

### 3. Apilado en Orden Correcto ‚úÖ

**Criterio:** Bandas apiladas en orden exacto [B02, B03, B04, B8A, B11, B12]

**Implementaci√≥n:**
- Crear funci√≥n `stack_hls_bands()` en `src/features/hls_processor.py`
- Validar orden de bandas
- Validar dimensiones consistentes
- Retornar array (6, H, W)

**Tests:**
- Test de orden correcto
- Test de dimensiones
- Test de validaci√≥n de bandas faltantes
- Test de manejo de errores

**C√≥digo Esperado:**
```python
def stack_hls_bands(
    bands_dict: Dict[str, np.ndarray],
    validate: bool = True
) -> np.ndarray:
    """
    Stack HLS bands in correct order for Prithvi.
    
    Parameters
    ----------
    bands_dict : dict
        Dictionary with band names as keys
    validate : bool
        Whether to validate band order and dimensions
        
    Returns
    -------
    np.ndarray
        Stacked bands (6, H, W)
    """
    required_bands = ['B02', 'B03', 'B04', 'B8A', 'B11', 'B12']
    
    if validate:
        for band in required_bands:
            if band not in bands_dict:
                raise ValueError(f"Missing required band: {band}")
    
    return np.stack([bands_dict[b] for b in required_bands], axis=0)
```

### 4. Normalizaci√≥n de Imagen ‚úÖ

**Criterio:** Imagen normalizada con mean=0, std=1

**Implementaci√≥n:**
- Usar funci√≥n existente `normalize_hls_image()` de `src/models/prithvi_loader.py`
- Validar que la normalizaci√≥n sea correcta
- Manejar valores extremos (NaN, Inf)

**Tests:**
- Test de normalizaci√≥n correcta (mean ‚âà 0, std ‚âà 1)
- Test de manejo de NaN
- Test de manejo de Inf
- Test de preservaci√≥n de shape

### 5. Inferencia con Prithvi ‚úÖ

**Criterio:** Embeddings extra√≠dos con shape (H, W, 256)

**Implementaci√≥n:**
- Usar `load_prithvi_model()` existente
- Configurar para usar modelo real (use_simple_model=False)
- Extraer embeddings del encoder
- Interpolar a resoluci√≥n original si es necesario

**Tests:**
- Test de inferencia exitosa
- Test de shape de salida
- Test de rango de valores
- Test de determinismo

**C√≥digo Esperado:**
```python
def extract_embeddings(
    hls_image: np.ndarray,
    model_path: Optional[str] = None,
    use_simple_model: bool = False,
    device: Optional[str] = None
) -> np.ndarray:
    """
    Extract semantic embeddings from HLS image using Prithvi.
    
    Parameters
    ----------
    hls_image : np.ndarray
        HLS image (6, H, W) with bands in order:
        [B02, B03, B04, B8A, B11, B12]
    model_path : str, optional
        Path to Prithvi model weights
    use_simple_model : bool
        Use simplified model for testing
    device : str, optional
        'cuda' or 'cpu'
        
    Returns
    -------
    np.ndarray
        Embeddings (H, W, 256)
    """
    from src.models.prithvi_loader import (
        load_prithvi_model, 
        normalize_hls_image,
        interpolate_embeddings
    )
    import torch
    
    # Convert to tensor
    hls_tensor = torch.from_numpy(hls_image).unsqueeze(0).float()
    
    # Normalize
    hls_normalized = normalize_hls_image(hls_tensor, method='standardize')
    
    # Load model
    encoder = load_prithvi_model(
        model_path=model_path,
        use_simple_model=use_simple_model,
        device=device
    )
    
    # Extract embeddings
    with torch.no_grad():
        embeddings = encoder(hls_normalized)  # (1, 256, H', W')
    
    # Interpolate to original resolution if needed
    original_size = (hls_image.shape[1], hls_image.shape[2])
    if embeddings.shape[2:] != original_size:
        embeddings = interpolate_embeddings(
            embeddings, 
            target_size=original_size,
            mode='bilinear'
        )
    
    # Convert to numpy (H, W, 256)
    embeddings_np = embeddings.squeeze(0).permute(1, 2, 0).cpu().numpy()
    
    return embeddings_np
```

### 6. Normalizaci√≥n de Embeddings (L2 Norm) ‚úÖ

**Criterio:** Embeddings normalizados para cosine similarity

**Implementaci√≥n:**
- Crear funci√≥n `normalize_embeddings_l2()` en `src/features/hls_processor.py`
- Normalizar cada vector de 256D a norma L2 = 1
- Validar que la normalizaci√≥n sea correcta

**Tests:**
- Test de normalizaci√≥n L2 correcta
- Test de preservaci√≥n de shape
- Test de manejo de vectores cero

**C√≥digo Esperado:**
```python
def normalize_embeddings_l2(embeddings: np.ndarray) -> np.ndarray:
    """
    Normalize embeddings using L2 norm for cosine similarity.
    
    Parameters
    ----------
    embeddings : np.ndarray
        Embeddings (H, W, 256)
        
    Returns
    -------
    np.ndarray
        L2-normalized embeddings (H, W, 256)
    """
    norms = np.linalg.norm(embeddings, axis=2, keepdims=True)
    # Avoid division by zero
    norms = np.where(norms == 0, 1, norms)
    return embeddings / norms
```

### 7. Tests Unitarios Completos ‚úÖ

**Criterio:** 20+ tests unitarios con cobertura >80%

**Tests a Implementar:**
- `test_download_hls_bands_success`
- `test_download_hls_bands_invalid_bbox`
- `test_download_hls_bands_no_data`
- `test_resample_band_to_10m_dimensions`
- `test_resample_band_to_10m_quality`
- `test_resample_band_to_10m_target_shape`
- `test_stack_hls_bands_correct_order`
- `test_stack_hls_bands_missing_band`
- `test_stack_hls_bands_dimensions`
- `test_normalize_hls_image_mean_std`
- `test_normalize_hls_image_nan_handling`
- `test_extract_embeddings_shape`
- `test_extract_embeddings_determinism`
- `test_extract_embeddings_simple_model`
- `test_extract_embeddings_real_model`
- `test_normalize_embeddings_l2_norm`
- `test_normalize_embeddings_l2_zero_vector`
- `test_full_pipeline_integration`
- `test_performance_large_image`
- `test_memory_usage`

### 8. Notebook de Demostraci√≥n ‚úÖ

**Criterio:** Notebook funcional con visualizaciones

**Contenido:**
1. Introducci√≥n y contexto (en espa√±ol)
2. Descarga de im√°genes de M√©xico (3 zonas)
3. Procesamiento de bandas HLS
4. Extracci√≥n de embeddings
5. Visualizaci√≥n de embeddings (PCA, t-SNE)
6. Comparaci√≥n de embeddings entre regiones
7. An√°lisis de similitud sem√°ntica
8. Comparaci√≥n entre zonas de M√©xico
9. Conclusiones (en espa√±ol)

### 9. Endpoints de API FastAPI ‚úÖ

**Criterio:** Endpoints funcionales integrados con la API existente

**Endpoints a Implementar:**

#### POST /api/embeddings/extract
Extrae embeddings de una regi√≥n espec√≠fica

**Request:**
```json
{
  "bbox": {
    "min_lat": 32.45,
    "min_lon": -115.35,
    "max_lat": 32.55,
    "max_lon": -115.25
  },
  "date_from": "2024-01-01",
  "date_to": "2024-01-31",
  "use_simple_model": false
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "embeddings_shape": [512, 512, 256],
    "embeddings_url": "/api/embeddings/download/abc123",
    "metadata": {
      "bbox": {...},
      "date": "2024-01-15",
      "bands_used": ["B02", "B03", "B04", "B8A", "B11", "B12"],
      "model": "prithvi-real"
    }
  }
}
```

#### GET /api/embeddings/download/{embedding_id}
Descarga embeddings en formato numpy (.npy)

#### POST /api/embeddings/similarity
Calcula similitud entre dos regiones

**Request:**
```json
{
  "region_a": {
    "bbox": {...},
    "date": "2024-01-15"
  },
  "region_b": {
    "bbox": {...},
    "date": "2024-01-15"
  }
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "cosine_similarity": 0.87,
    "euclidean_distance": 2.34,
    "interpretation": "high_similarity"
  }
}
```

**Tests:**
- Test de extracci√≥n exitosa
- Test de validaci√≥n de bbox
- Test de manejo de errores
- Test de descarga de embeddings
- Test de c√°lculo de similitud

---

## üîß Implementaci√≥n T√©cnica

### Fase 1: Descarga de Bandas HLS (2 horas)

**Tareas:**
1. Modificar `src/utils/sentinel_download.py`
   - Agregar funci√≥n `download_hls_bands()`
   - Crear evalscript para 6 bandas
   - Manejar resoluciones diferentes
2. Crear script `scripts/download_hls_image.py`
   - Script CLI para descargar im√°genes
   - Configurar zonas de M√©xico (Mexicali, Baj√≠o, Sinaloa)
   - Guardar bandas en `img/sentinel2/mexico/`
3. Tests b√°sicos de descarga
4. Descargar im√°genes de las 3 zonas de M√©xico

**Entregable:** Funci√≥n de descarga funcional + im√°genes de M√©xico descargadas

### Fase 2: Procesamiento HLS (3 horas)

**Tareas:**
1. Crear `src/features/hls_processor.py`
   - Funci√≥n `resample_band_to_10m()`
   - Funci√≥n `stack_hls_bands()`
   - Funci√≥n `normalize_embeddings_l2()`
   - Funci√≥n `extract_embeddings()` (wrapper completo)
2. Tests unitarios de procesamiento (15+ tests)
3. Validaci√≥n de calidad de remuestreo

**Entregable:** M√≥dulo HLS processor completo

### Fase 3: Integraci√≥n con Prithvi (2 horas)

**Tareas:**
1. Integrar con `src/models/prithvi_loader.py`
2. Probar con modelo simple
3. Probar con modelo real
4. Optimizar performance
5. Tests de integraci√≥n

**Entregable:** Pipeline completo funcional

### Fase 4: Testing y Validaci√≥n (2 horas)

**Tareas:**
1. Completar tests unitarios (20+ tests)
2. Tests de integraci√≥n
3. Profiling de performance
4. Validaci√≥n de memoria
5. Cobertura de c√≥digo >80%

**Entregable:** Suite de tests completa

### Fase 5: Integraci√≥n con API (2 horas)

**Tareas:**
1. Crear `backend/app/api/routes/embeddings.py`
   - Endpoint POST /api/embeddings/extract
   - Endpoint GET /api/embeddings/download/{id}
   - Endpoint POST /api/embeddings/similarity
2. Crear `backend/app/services/embeddings_service.py`
   - Servicio orquestador (wrapper delgado)
   - Usa funciones de `src/features/hls_processor.py`
3. Actualizar schemas (requests.py, responses.py)
4. Tests de endpoints API (5+ tests)

**Entregable:** API funcional con embeddings

### Fase 6: Documentaci√≥n y Demo (1 hora)

**Tareas:**
1. Crear notebook `us-006-embeddings-demo.ipynb`
   - Descargar im√°genes de 3 zonas de M√©xico
   - Visualizaciones de embeddings
   - Comparaci√≥n entre zonas
2. Documentaci√≥n en `src/features/README.md`
3. Actualizar Swagger docs
4. Actualizar documentaci√≥n principal

**Entregable:** Documentaci√≥n y demo completos

---

## üìä M√©tricas de √âxito

| M√©trica | Objetivo | C√≥mo Medir |
|---------|----------|------------|
| Tests unitarios | 20+ | `pytest tests/unit/test_hls_processor.py -v` |
| Tests API | 5+ | `pytest tests/unit/test_embeddings_api.py -v` |
| Cobertura de c√≥digo | >80% | `pytest --cov=src.features --cov-report=html` |
| Performance descarga | <30s | Tiempo de descarga de imagen 512x512 |
| Performance remuestreo | <1s | Tiempo de remuestreo de 3 bandas |
| Performance inferencia | <5s | Tiempo de extracci√≥n de embeddings |
| Memoria GPU | <2GB | Uso de VRAM durante inferencia |
| Calidad embeddings | Validaci√≥n visual | Notebook de demostraci√≥n |
| Im√°genes de M√©xico | 3 zonas | Mexicali, Baj√≠o, Sinaloa descargadas |
| Endpoints API | 3 | extract, download, similarity funcionando |
| Cumplimiento AGENTS.md | 100% | Revisi√≥n manual |

---

## üö® Riesgos y Mitigaciones

### Riesgo 1: Bandas Incorrectas
**Probabilidad:** Media  
**Impacto:** Alto  
**Mitigaci√≥n:**
- Validaci√≥n estricta de orden de bandas
- Tests que verifican orden correcto
- Documentaci√≥n clara de bandas requeridas

### Riesgo 2: Calidad de Remuestreo
**Probabilidad:** Baja  
**Impacto:** Medio  
**Mitigaci√≥n:**
- Usar interpolaci√≥n bilinear (est√°ndar)
- Validar visualmente calidad
- Comparar con remuestreo de referencia

### Riesgo 3: Memoria Insuficiente
**Probabilidad:** Baja  
**Impacto:** Alto  
**Mitigaci√≥n:**
- Procesar im√°genes en batches si es necesario
- Usar modelo simple para desarrollo
- Monitorear uso de memoria

### Riesgo 4: Performance Lenta
**Probabilidad:** Media  
**Impacto:** Medio  
**Mitigaci√≥n:**
- Optimizar remuestreo con scipy
- Usar GPU para inferencia
- Cachear embeddings si es posible

### Riesgo 5: Modelo No Descargado
**Probabilidad:** Baja  
**Impacto:** Bajo  
**Mitigaci√≥n:**
- Usar modelo simple como fallback
- Documentar proceso de descarga
- Script autom√°tico de descarga

---

## üìö Referencias T√©cnicas

### Papers
1. **Jakubik et al. (2024).** Foundation models for generalist geospatial AI. arXiv:2310.18660
   - Prithvi architecture and training
2. **Claverie et al. (2018).** The Harmonized Landsat and Sentinel-2 surface reflectance data set.
   - HLS specification and band definitions

### Documentaci√≥n
- **Prithvi HuggingFace:** https://huggingface.co/ibm-nasa-geospatial/Prithvi-EO-1.0-100M
- **HLS User Guide:** https://lpdaac.usgs.gov/documents/1698/HLS_User_Guide_V2.pdf
- **Sentinel-2 Band Info:** https://sentinels.copernicus.eu/web/sentinel/user-guides/sentinel-2-msi/resolutions/radiometric
- **scipy.ndimage.zoom:** https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.zoom.html

### C√≥digo de Referencia
- `src/models/prithvi_loader.py` - Carga del modelo
- `src/utils/sentinel_download.py` - Descarga de Sentinel-2
- `src/features/ndvi_calculator.py` - Ejemplo de feature engineering

---

## üîó Dependencias

### Bloqueantes (Deben estar completas)
- ‚úÖ US-003: Arquitectura Limpia + Descarga Sentinel-2
- ‚úÖ US-005: Descargar y Configurar Prithvi

### Desbloqueadas (Se pueden iniciar despu√©s)
- US-007: Implementar MGRG (necesita embeddings de US-006)
- US-008: Comparativa A/B visual (necesita MGRG de US-007)

---

## üìã Checklist de Implementaci√≥n

### C√≥digo
- [ ] Funci√≥n `download_hls_bands()` implementada
- [ ] Funci√≥n `resample_band_to_10m()` implementada
- [ ] Funci√≥n `stack_hls_bands()` implementada
- [ ] Funci√≥n `normalize_embeddings_l2()` implementada
- [ ] Funci√≥n `extract_embeddings()` implementada
- [ ] Script `download_hls_image.py` creado
- [ ] Script `test_embeddings.py` creado
- [ ] Im√°genes de M√©xico descargadas (3 zonas)

### API
- [ ] Endpoint POST /api/embeddings/extract implementado
- [ ] Endpoint GET /api/embeddings/download/{id} implementado
- [ ] Endpoint POST /api/embeddings/similarity implementado
- [ ] Servicio `embeddings_service.py` creado
- [ ] Schemas actualizados (EmbeddingsRequest, EmbeddingsResponse)
- [ ] Documentaci√≥n Swagger actualizada

### Tests
- [ ] 20+ tests unitarios implementados (hls_processor)
- [ ] 5+ tests de API implementados (embeddings_api)
- [ ] Tests de integraci√≥n implementados
- [ ] Cobertura >80% alcanzada
- [ ] Todos los tests pasan

### Documentaci√≥n
- [ ] Docstrings completos (estilo Google, ingl√©s)
- [ ] `src/features/README.md` creado
- [ ] Notebook de demostraci√≥n creado
- [ ] Comentarios en c√≥digo (ingl√©s)

### Validaci√≥n
- [ ] Bandas correctas validadas
- [ ] Orden de bandas validado
- [ ] Calidad de remuestreo validada
- [ ] Embeddings visualizados
- [ ] Im√°genes de M√©xico procesadas exitosamente
- [ ] Comparaci√≥n entre zonas de M√©xico realizada
- [ ] Endpoints API probados con Postman/Swagger
- [ ] Performance medida

### Cumplimiento AGENTS.md
- [ ] C√≥digo en ingl√©s
- [ ] Documentaci√≥n en espa√±ol/ingl√©s seg√∫n convenci√≥n
- [ ] Type hints en todas las funciones
- [ ] Sin emojis en comentarios de c√≥digo
- [ ] Logging profesional
- [ ] Funciones reutilizables en `src/`

---

## üéØ Definici√≥n de "Hecho"

La US-006 se considera completada cuando:

1. ‚úÖ Todas las funciones implementadas y funcionando
2. ‚úÖ 20+ tests unitarios pasando (hls_processor)
3. ‚úÖ 5+ tests de API pasando (embeddings_api)
4. ‚úÖ Cobertura de c√≥digo >80%
5. ‚úÖ Im√°genes de 3 zonas de M√©xico descargadas y procesadas
6. ‚úÖ Endpoints de API funcionando (extract, download, similarity)
7. ‚úÖ Notebook de demostraci√≥n funcional con comparaci√≥n de zonas
8. ‚úÖ Documentaci√≥n completa (c√≥digo + API)
9. ‚úÖ Embeddings extra√≠dos correctamente (validaci√≥n visual)
10. ‚úÖ Performance dentro de objetivos
11. ‚úÖ Cumplimiento 100% con AGENTS.md
12. ‚úÖ C√≥digo revisado y aprobado
13. ‚úÖ Sin breaking changes en c√≥digo existente
14. ‚úÖ Swagger docs actualizado con nuevos endpoints

---

## üí° Notas Adicionales

### Decisi√≥n: Modelo Simple vs Real

Para desarrollo y testing inicial, usar `use_simple_model=True`:
- Carga instant√°nea
- No requiere descarga
- Suficiente para validar pipeline

Para producci√≥n y resultados finales, usar `use_simple_model=False`:
- Pesos pre-entrenados de NASA/IBM
- Mejor calidad de embeddings
- M√°s r√°pido en inferencia

### Optimizaciones Futuras (Post-US-006)

1. **Caching de Embeddings**
   - Guardar embeddings en disco
   - Evitar re-computar para misma imagen

2. **Batch Processing**
   - Procesar m√∫ltiples im√°genes en batch
   - Mejor uso de GPU

3. **Resoluci√≥n Adaptativa**
   - Ajustar resoluci√≥n seg√∫n disponibilidad de memoria
   - Procesar im√°genes grandes en tiles

4. **Formato Optimizado**
   - Guardar embeddings en formato comprimido
   - Usar HDF5 o Zarr para grandes vol√∫menes

---

## üë• Equipo y Roles

**Responsable Principal:** Arthur Zizumbo  
**Soporte:** Luis V√°zquez  
**Revisor:** Carlos Bocanegra  
**Proyecto:** Sistema H√≠brido de Detecci√≥n de Estr√©s Vegetal  
**Equipo:** 24 - Region Growing  
**Sprint:** Innovaci√≥n SOTA (D√≠as 4-7)

---

**Estado:** üìã PLANIFICACI√ìN COMPLETA  
**Versi√≥n:** 1.0.0  
**Fecha de Planificaci√≥n:** 9 de Noviembre de 2025  
**Listo para Implementaci√≥n:** ‚úÖ S√ç

---

## üöÄ Pr√≥ximos Pasos

1. **Revisi√≥n de Planificaci√≥n** - Aprobar este documento
2. **Inicio de Implementaci√≥n** - Comenzar con Fase 1
3. **Descarga de Im√°genes de M√©xico** - Obtener datos de las 3 zonas
4. **Daily Standups** - Reportar progreso diario
5. **Code Reviews** - Revisar c√≥digo en cada fase
6. **Pruebas de API** - Validar endpoints con Postman/Swagger
7. **Demo Final** - Presentar notebook con comparaci√≥n de zonas mexicanas

---

## üìç Datos de Prueba - Zonas de M√©xico

Para facilitar la implementaci√≥n, aqu√≠ est√°n las coordenadas exactas:

```python
# Zonas de prueba en M√©xico
MEXICO_TEST_ZONES = {
    'mexicali': {
        'name': 'Valle de Mexicali, Baja California',
        'bbox': {
            'min_lat': 32.45,
            'min_lon': -115.35,
            'max_lat': 32.55,
            'max_lon': -115.25
        },
        'description': 'Agricultura intensiva de riego - Trigo, algod√≥n',
        'expected_stress': 'variable (depende de riego)'
    },
    'bajio': {
        'name': 'Baj√≠o, Guanajuato',
        'bbox': {
            'min_lat': 20.85,
            'min_lon': -101.45,
            'max_lat': 20.95,
            'max_lon': -101.35
        },
        'description': 'Agricultura diversa - Ma√≠z, sorgo, hortalizas',
        'expected_stress': 'bajo a medio'
    },
    'sinaloa': {
        'name': 'Valle de Culiac√°n, Sinaloa',
        'bbox': {
            'min_lat': 24.75,
            'min_lon': -107.45,
            'max_lat': 24.85,
            'max_lon': -107.35
        },
        'description': 'Agricultura de exportaci√≥n - Tomate, chile',
        'expected_stress': 'bajo (riego tecnificado)'
    }
}
```

---

**¬øAprobado para iniciar implementaci√≥n?** ‚è≥ Pendiente de aprobaci√≥n
